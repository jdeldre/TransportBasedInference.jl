<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API Documentation · TransportBasedInference.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TransportBasedInference.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><a class="tocitem" href="../../background/">Background</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/3.-Structure-discovery-of-the-Lorenz-96/">3. Structure discovery for the Lorenz-96 problem</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>API Documentation</a><ul class="internal"><li><a class="tocitem" href="#Functions"><span>Functions</span></a></li><li><a class="tocitem" href="#Types"><span>Types</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li><li><a class="tocitem" href="../contribute/">Community guidelines</a></li><li><a class="tocitem" href="../LICENSE/">LICENSE</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>API Documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API Documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/master/docs/src/manual/apidoc.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Documentation"><a class="docs-heading-anchor" href="#API-Documentation">API Documentation</a><a id="API-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#API-Documentation" title="Permalink"></a></h1><h2 id="Functions"><a class="docs-heading-anchor" href="#Functions">Functions</a><a id="Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.size-Tuple{MultiAddInflation}" href="#Base.size-Tuple{MultiAddInflation}"><code>Base.size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">size(A::MultiAddInflation)</code></pre><p>Return the dimension of the additive inflation of <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/inflation.jl#L279-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},ExpandedFunction}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},ExpandedFunction}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    heatmap(M::HermiteMap; start::Int64=1, color, degree)</code></pre><p>Plot recipe for an <code>ExpandedFunction</code>.  We can either plot the number of occurences of each variable (columns) in each map component (rows) if <code>degree = false</code> (default behavior), or the maximum multi-index of the features identified for each variable (columns) in each map component (rows) if <code>degree = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/plot_recipes.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},HermiteMap}" href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},HermiteMap}"><code>RecipesBase.apply_recipe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    heatmap(M::HermiteMap; start::Int64=1, color, degree)</code></pre><p>Plot recipe for an <code>HermiteMap</code>. We can either plot the number of occurences of each variable (columns) in each map component (rows) if <code>degree = false</code> (default behavior), or the maximum multi-index of the features identified for each variable (columns) in each map component (rows) if <code>degree = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/plot_recipes.jl#L37-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.DPhyPolyHermite-Tuple{Int64}" href="#TransportBasedInference.DPhyPolyHermite-Tuple{Int64}"><code>TransportBasedInference.DPhyPolyHermite</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitefunction/phyhermite.jl#L50-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.Diff-Tuple{Any,Any}" href="#TransportBasedInference.Diff-Tuple{Any,Any}"><code>TransportBasedInference.Diff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Diff(f,k)</code></pre><p>By recurrence, create the k-th derivative of the scalar function <code>f</code>, based on <code>ForwardDiff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/ADtools.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.Diff-Tuple{Any}" href="#TransportBasedInference.Diff-Tuple{Any}"><code>TransportBasedInference.Diff</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Diff(f)</code></pre><p>Create the derivative of the scalar function <code>f</code>, based on <code>ForwardDiff</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/ADtools.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.allequal-Tuple{Any,Any}" href="#TransportBasedInference.allequal-Tuple{Any,Any}"><code>TransportBasedInference.allequal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">allequal(x, r)</code></pre><p>A function to verify that all the entries of the vector <code>x</code> are equal to <code>r</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/tools.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.bisection-NTuple{6,Any}" href="#TransportBasedInference.bisection-NTuple{6,Any}"><code>TransportBasedInference.bisection</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Implement the classical Bisection algorithm on the segment <code>[xm, xp]</code> of the real function <code>f</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/hybridinverse.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.clenshaw_curtis-Tuple{Int64}" href="#TransportBasedInference.clenshaw_curtis-Tuple{Int64}"><code>TransportBasedInference.clenshaw_curtis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clenshaw_curtis(N)</code></pre><p>Compute the nodes <code>x</code> and weights <code>w</code> for integrating a continuous functions from [-1,1] using the Clenshaw-Curtis integration rule with order <code>N</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/clenshaw_curtis.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.csne-Union{Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,2},Array{T,1}}} where T" href="#TransportBasedInference.csne-Union{Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,2},Array{T,1}}} where T"><code>TransportBasedInference.csne</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Solve the corrected semi-normal equations <code>R&#39;Rx=A&#39;b</code>.</p><pre><code class="language-none">x, r = csne(R, A, b) solves the least-squares problem</code></pre><p>minimize  ||r||_2,  where  r := b - A*x</p><p>using the corrected semi-normal equation approach described by Bjork (1987). Assumes that <code>R</code> is upper triangular.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/qr.jl#L187-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.degree-Tuple{PhyHermite}" href="#TransportBasedInference.degree-Tuple{PhyHermite}"><code>TransportBasedInference.degree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    degree(P)</code></pre><p>Return the degree of the polynomial <code>P</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitefunction/phyhermite.jl#L36-L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.elementproductmatmul!-Tuple{Array{Float64,1},Array{Float64,2},Array{Float64,2},Array{Float64,1}}" href="#TransportBasedInference.elementproductmatmul!-Tuple{Array{Float64,1},Array{Float64,2},Array{Float64,2},Array{Float64,1}}"><code>TransportBasedInference.elementproductmatmul!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">elementproductmatmul!(d, A, B, c)</code></pre><p>Compute in-place the product <code>(A ∘ B)*c</code>, where <code>∘</code> denotes the element-wise  product of two matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/product.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.exactn-Tuple{Any}" href="#TransportBasedInference.exactn-Tuple{Any}"><code>TransportBasedInference.exactn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    exactn(N)</code></pre><p>A function to create a 1D sample with exactly mean 0 and covariance 1 (The samples are no longer i.i.d but this can be usueful when the initialization of the problem is challenging.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/inflation.jl#L11-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.fact2-Tuple{Int64}" href="#TransportBasedInference.fact2-Tuple{Int64}"><code>TransportBasedInference.fact2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fact2(n)</code></pre><p>Compute the double factorial of <code>n</code>, i.e. the product of the odd (if <code>n</code> is odd) or even (if <code>n</code> is even) numbers up to <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/tools.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.grad_x_logeval-Union{Tuple{T}, Tuple{Rectifier,T}} where T&lt;:Real" href="#TransportBasedInference.grad_x_logeval-Union{Tuple{T}, Tuple{Rectifier,T}} where T&lt;:Real"><code>TransportBasedInference.grad_x_logeval</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute g′(x)/g(x) i.e d/dx log(g(x))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/rectifier.jl#L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.gradlog_pdf-Tuple{Any}" href="#TransportBasedInference.gradlog_pdf-Tuple{Any}"><code>TransportBasedInference.gradlog_pdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gradlog_pdf(x)</code></pre><p>Compute the gradient of the log of the density of the univariate standard Gaussian distribution (zero mean and unitary standard deviation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/normal.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.greedyfit-Tuple{Int64,Int64,Any,Any,Int64}" href="#TransportBasedInference.greedyfit-Tuple{Int64,Int64,Any,Any,Int64}"><code>TransportBasedInference.greedyfit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">greedyfit(m::Int64, Nx::Int64, X, Xvalid, maxterms::Int64; withconstant, withqr, maxpatience, verbose, hessprecond) -&gt; Tuple{HermiteMapComponent,Tuple{Array{Float64,1},Array{Float64,1}}}
</code></pre><p>An adaptive routine to estimate a sparse approximation of an <code>HermiteMapComponent</code> based on  the pair of ensemble matrices <code>X</code> (training set) and <code>Xvalid</code> (validation set).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/greedyfit.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.greedyfit-Tuple{Int64,Int64,Any,Int64}" href="#TransportBasedInference.greedyfit-Tuple{Int64,Int64,Any,Int64}"><code>TransportBasedInference.greedyfit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">greedyfit(m::Int64, Nx::Int64, X, maxterms::Int64; withconstant, withqr, maxpatience, verbose, hessprecond) -&gt; Tuple{HermiteMapComponent,Array{Float64,1}}
</code></pre><p>An adaptive routine to estimate a sparse approximation of an <code>HermiteMapComponent</code> based on  the ensemble matrix <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/greedyfit.jl#L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.greedyfit-Tuple{Int64,Int64,Int64,AbstractArray{Float64,2},AbstractArray{Float64,2},Int64,Float64,Float64,Float64}" href="#TransportBasedInference.greedyfit-Tuple{Int64,Int64,Int64,AbstractArray{Float64,2},AbstractArray{Float64,2},Int64,Float64,Float64,Float64}"><code>TransportBasedInference.greedyfit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">greedyfit(Nx::Int64, poff::Int64, pdiag::Int64, X::AbstractArray{Float64,2}, Xvalid::AbstractArray{Float64,2}, maxfamiliesoff::Int64, λ::Float64, δ::Float64, γ::Float64; maxpatience, verbose) -&gt; Tuple{SparseRadialMapComponent,Tuple{Array{Float64,1},Array{Float64,1}}}
</code></pre><p>An adaptive routine to estimate a sparse approximation of an <code>SparseRadialMapComponent</code> based on  the pair of ensemble matrices <code>X</code> (training set) and <code>Xvalid</code> (validation set).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/radialmap/greedyfit.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.greedyfit-Tuple{Int64,Int64,Int64,AbstractArray{Float64,2},Int64,Float64,Float64,Float64}" href="#TransportBasedInference.greedyfit-Tuple{Int64,Int64,Int64,AbstractArray{Float64,2},Int64,Float64,Float64,Float64}"><code>TransportBasedInference.greedyfit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">greedyfit(Nx::Int64, poff::Int64, pdiag::Int64, X::AbstractArray{Float64,2}, maxfamiliesoff::Int64, λ::Float64, δ::Float64, γ::Float64; maxpatience, verbose) -&gt; Tuple{SparseRadialMapComponent,Array{Float64,1}}
</code></pre><p>An adaptive routine to estimate a sparse approximation of an <code>SparseRadialMapComponent</code> based on  the ensemble matrix <code>X</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/radialmap/greedyfit.jl#L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.hesslog_pdf-Tuple{Any}" href="#TransportBasedInference.hesslog_pdf-Tuple{Any}"><code>TransportBasedInference.hesslog_pdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hesslog_pdf(x)</code></pre><p>Compute the hessian of the log of the density of the univariate standard Gaussian distribution (zero mean and unitary standard deviation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/normal.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.log_pdf-Tuple{Any}" href="#TransportBasedInference.log_pdf-Tuple{Any}"><code>TransportBasedInference.log_pdf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log_pdf(x)</code></pre><p>Compute the log of the density of the univariate standard Gaussian distribution (zero mean and unitary standard deviation).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/normal.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.log_pdf_banana-Tuple{AbstractArray{T,1} where T}" href="#TransportBasedInference.log_pdf_banana-Tuple{AbstractArray{T,1} where T}"><code>TransportBasedInference.log_pdf_banana</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log_pdf_banana(X; μ = 0.0, σ = 2.0, bananicity = 0.2)</code></pre><p>Compute the logarithm of the porbability density function (pdf) of the Banana distribution at <code>X</code>. See documentation of sample_banana for details on the Banana distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/banana.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.lorenz63!-NTuple{4,Any}" href="#TransportBasedInference.lorenz63!-NTuple{4,Any}"><code>TransportBasedInference.lorenz63!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lorenz63!(du,u,p,t)</code></pre><p>Compute in-place the right-hand-side of the Lorenz-63 system for a state <code>u</code> at time <code>t</code>, and store it in <code>du</code>. <code>p</code> is vector of user-defined parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/lorenz63/lorenz63.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.lorenz96!-NTuple{4,Any}" href="#TransportBasedInference.lorenz96!-NTuple{4,Any}"><code>TransportBasedInference.lorenz96!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">lorenz96!(du,u,p,t)</code></pre><p>Compute in-place the right-hand-side of the Lorenz-96 system for a state <code>u</code> at time <code>t</code>, and store it in <code>du</code>. <code>p</code> is vector of user-defined parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/lorenz96/lorenz96.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.mean_hist-Tuple{Array{Array{Float64,2},1}}" href="#TransportBasedInference.mean_hist-Tuple{Array{Array{Float64,2},1}}"><code>TransportBasedInference.mean_hist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mean_hist(hist)</code></pre><p>Stack together the mean of the different ensembles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/metric.jl#L63-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.meas-Tuple{Any,Any,Any}" href="#TransportBasedInference.meas-Tuple{Any,Any,Any}"><code>TransportBasedInference.meas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">meas(X, Ny, Nx)</code></pre><p>A function to extract the first <code>Ny</code> lines of the ensemble matrix <code>X</code>, typically storing the observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/view.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.member-Tuple{Any,Any}" href="#TransportBasedInference.member-Tuple{Any,Any}"><code>TransportBasedInference.member</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">member(X, idx)</code></pre><p>Extract the <code>idx</code> ensemble member of the ensemble matrix <code>X</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/tools.jl#L20-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.observe-Tuple{Function,Any,Float64,Int64,Int64}" href="#TransportBasedInference.observe-Tuple{Function,Any,Float64,Int64,Int64}"><code>TransportBasedInference.observe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">observe(h::Function, X, t::Float64, Ny::Int64, Nx::Int64; P)
</code></pre><p>Evaluate the function <code>h</code> for the different state vectors of the <code>X</code> at time <code>t</code>, and store the results in the first <code>Ny</code> columns of <code>X</code>. <code>X</code> is an ensemble matrix that contains the observation vectors in the first <code>Ny</code> lines, and the state vectors in the lines <code>Ny+1</code> to <code>Ny+Nx</code>. The code can run in serial or with multithreading.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/statespace/system.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.observe-Tuple{StateSpace,Array{Float64,1},Float64}" href="#TransportBasedInference.observe-Tuple{StateSpace,Array{Float64,1},Float64}"><code>TransportBasedInference.observe</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">observe(F::StateSpace, x::Array{Float64,1}, t::Float64) -&gt; Any
</code></pre><p>Apply the observation operator of the <code>StateSpace</code> <code>F</code> to the ensemble matrix <code>X</code> at time <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/statespace/system.jl#L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.qraddrow-Union{Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,2}}} where T" href="#TransportBasedInference.qraddrow-Union{Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,2}}} where T"><code>TransportBasedInference.qraddrow</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Add a row and update a Q-less QR factorization.</p><p>qraddrow!(R, a) returns the triangular part of a QR factorization of [A; a], where A = QR for some Q.  The argument &#39;a&#39; should be a row vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/qr.jl#L126-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.qrdelcol-Union{Tuple{T}, Tuple{AbstractArray{T,2},Int64}} where T" href="#TransportBasedInference.qrdelcol-Union{Tuple{T}, Tuple{AbstractArray{T,2},Int64}} where T"><code>TransportBasedInference.qrdelcol</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Delete the k-th column and update a Q-less QR factorization.</p><p><code>R = qrdelcol(R,k)</code> deletes the k-th column of the upper-triangular <code>R</code> and restores it to upper-triangular form.  On input, <code>R</code> is an n x n upper-triangular matrix.  On output, <code>R</code> is an n-1 x n-1 upper triangle.</p><pre><code class="language-none">18 Jun 2007: First version of QRdelcol.m.
             Michael Friedlander (mpf@cs.ubc.ca) and
             Michael Saunders (saunders@stanford.edu)
             To allow for R being sparse,
             we eliminate the k-th row of the usual
             Hessenberg matrix rather than its subdiagonals,
             as in Reid&#39;s Bartel-Golub LU update and also
             the Forrest-Tomlin update.
             (But Matlab will still be pretty inefficient.)
18 Jun 2007: R is now the exact size on entry and exit.
30 Dec 2015: Translate to Julia.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/qr.jl#L146-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.rdnortho-Tuple{Int64}" href="#TransportBasedInference.rdnortho-Tuple{Int64}"><code>TransportBasedInference.rdnortho</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rdnortho(N::Int64) -&gt; Array{Float64,2}
</code></pre><p>A routine to generate mean-preserving random rotations.</p><p>References:</p><p>Nerger, L., Janjić, T., Schröter, J., &amp; Hiller, W. (2012). A unification of ensemble square root Kalman filters. Monthly Weather Review, 140(7), 2335-2345. Tödter, J., &amp; Ahrens, B. (2015). A second-order exact ensemble square root filter for nonlinear data assimilation. Monthly Weather Review, 143(4), 1347-1367.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/enkf/etkf.jl#L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.rmse-Tuple{Array{Float64,1},Array{Float64,2}}" href="#TransportBasedInference.rmse-Tuple{Array{Float64,1},Array{Float64,2}}"><code>TransportBasedInference.rmse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rmse(X)</code></pre><p>Compute the root-mean square error of the ensemble matrix <code>X</code>    </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/metric.jl#L49-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.sample_banana-Tuple{Any}" href="#TransportBasedInference.sample_banana-Tuple{Any}"><code>TransportBasedInference.sample_banana</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sample_banana(N; μ = 0.0, σ = 2.0, bananicity = 0.2)</code></pre><p>Generate <code>N</code> samples [x₁; x₂] of the Banana distribution defined as:     x₁ ∼ N(μ, σ²),     ϵ  ∼ N(0, 1),     x₂ ∼ bananicity × (x₁ - σ²) + ϵ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/banana.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.seqassim-Tuple{StateSpace,SyntheticData,Int64,InflationType,SeqFilter,Any,Any,Any,Float64,Localization}" href="#TransportBasedInference.seqassim-Tuple{StateSpace,SyntheticData,Int64,InflationType,SeqFilter,Any,Any,Any,Float64,Localization}"><code>TransportBasedInference.seqassim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">	seqassim(F::StateSpace, data::SyntheticData, J::Int64, ϵx::InflationType, algo::SeqFilter, X, Ny, Nx, t0::Float64, Loc::Localization)</code></pre><p>Generic API for localized sequential data assimilation for any sequential filter of parent type <code>SeqFilter</code> with localization scheme <code>Loc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/seqassim.jl#L69-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.seqassim-Tuple{StateSpace,SyntheticData,Int64,InflationType,SeqFilter,Any,Any,Any,Float64}" href="#TransportBasedInference.seqassim-Tuple{StateSpace,SyntheticData,Int64,InflationType,SeqFilter,Any,Any,Any,Float64}"><code>TransportBasedInference.seqassim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">	seqassim(F::StateSpace, data::SyntheticData, J::Int64, ϵx::InflationType, algo::SeqFilter, X, Ny, Nx, t0::Float64)</code></pre><p>Generic API for sequential data assimilation for any sequential filter of parent type <code>SeqFilter</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/seqassim.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.spread-Tuple{Array{Float64,2}}" href="#TransportBasedInference.spread-Tuple{Array{Float64,2}}"><code>TransportBasedInference.spread</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">spread(X)</code></pre><p>Compute the spread of the ensemble matrix <code>X</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/metric.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.state-Tuple{Any,Any,Any}" href="#TransportBasedInference.state-Tuple{Any,Any,Any}"><code>TransportBasedInference.state</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">state(X, Ny, Nx)</code></pre><p>A function to extract the lines <code>Ny+1</code> to <code>Ny+Nx</code> of the ensemble matrix <code>X</code>, typically storing the state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/view.jl#L17-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.vander!-Tuple{Any,CstLinPhyHermite,Int64,Int64,Any}" href="#TransportBasedInference.vander!-Tuple{Any,CstLinPhyHermite,Int64,Int64,Any}"><code>TransportBasedInference.vander!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vander!(dV, B::CstLinPhyHermite, maxi::Int64, k::Int64, x)</code></pre><p>Compute the Vandermonde matrix for the vector <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/basis.jl#L205-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.vander!-Tuple{Any,CstLinProHermite,Int64,Int64,Any}" href="#TransportBasedInference.vander!-Tuple{Any,CstLinProHermite,Int64,Int64,Any}"><code>TransportBasedInference.vander!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vander!(dV, B::CstLinProHermite, maxi::Int64, k::Int64, x)</code></pre><p>Compute the Vandermonde matrix for the vector <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/basis.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.vander!-Tuple{Any,CstPhyHermite,Int64,Int64,Any}" href="#TransportBasedInference.vander!-Tuple{Any,CstPhyHermite,Int64,Int64,Any}"><code>TransportBasedInference.vander!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vander!(dV, B::CstPhyHermite, maxi::Int64, k::Int64, x)</code></pre><p>Compute the Vandermonde matrix for the vector <code>x</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/basis.jl#L141-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.viewmeas-Tuple{Any,Any,Any}" href="#TransportBasedInference.viewmeas-Tuple{Any,Any,Any}"><code>TransportBasedInference.viewmeas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">viewmeas(X, Ny, Nx)</code></pre><p>Create a view of the first <code>Ny</code> lines of the ensemble matrix <code>X</code>, typically storing the observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/view.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.viewstate-Tuple{Any,Any,Any}" href="#TransportBasedInference.viewstate-Tuple{Any,Any,Any}"><code>TransportBasedInference.viewstate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">viewstate(X, Ny, Nx)</code></pre><p>Create a view of the lines <code>Ny+1</code> to <code>Ny+Nx</code> of the ensemble matrix <code>X</code>, typically storing the state.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/view.jl#L24-L28">source</a></section></article><h2 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.AdditiveInflation-Tuple{Any,Int64,Int64}" href="#TransportBasedInference.AdditiveInflation-Tuple{Any,Int64,Int64}"><code>TransportBasedInference.AdditiveInflation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    (A::AdditiveInflation)(X, start::Int64, final::Int64)</code></pre><p>Apply the additive inflation <code>A</code> to the lines <code>start</code> to <code>final</code> of an ensemble matrix <code>X</code>, i.e. xⁱ -&gt; xⁱ + ϵⁱ with ϵⁱ ∼ <code>A.α</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/inflation.jl#L123-L129">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.AdditiveInflation-Tuple{Any}" href="#TransportBasedInference.AdditiveInflation-Tuple{Any}"><code>TransportBasedInference.AdditiveInflation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    (A::AdditiveInflation)(X)</code></pre><p>Apply the additive inflation <code>A</code> to an ensemble matrix <code>X</code>, i.e. xⁱ -&gt; xⁱ + ϵⁱ with ϵⁱ ∼ <code>A.α</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/inflation.jl#L148-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.AdditiveInflation-Tuple{Array{Float64,1}}" href="#TransportBasedInference.AdditiveInflation-Tuple{Array{Float64,1}}"><code>TransportBasedInference.AdditiveInflation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    (A::AdditiveInflation)(x::Array{Float64,1})</code></pre><p>Apply the additive inflation <code>A</code> to the vector <code>x</code>, i.e. x -&gt; x + ϵ with ϵ ∼ <code>A.α</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/inflation.jl#L157-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.Basis" href="#TransportBasedInference.Basis"><code>TransportBasedInference.Basis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type Basis</code></pre><p>A structure to hold a basis of functions</p><p><strong>Fields</strong></p><p><strong>Constructors</strong></p><ul><li><code>Basis(m)</code></li></ul><p><strong>Construct new basis of features</strong></p><p>A specific feature basis <code>MyBasis</code> must be a subtype of <code>Basis</code>, and the following routines must be implemented:</p><ul><li><code>Base.show(io::IO, B::MyBasis)</code>` (optional, but desired)</li><li><code>@propagate_inbounds Base.getindex(B::MyBasis, i::Int64)</code></li><li><code>vander!(dV, B::MyBasis, maxi::Int64, k::Int64, x)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/basis.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.CstLinPhyHermite" href="#TransportBasedInference.CstLinPhyHermite"><code>TransportBasedInference.CstLinPhyHermite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CstLinPhyHermite &lt;: Basis</code></pre><p>The basis composed of the constant function, the identity, and physicist Hermite functions</p><p><strong>Fields</strong></p><ul><li><code>m::Int64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/basis.jl#L95">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.CstLinProHermite" href="#TransportBasedInference.CstLinProHermite"><code>TransportBasedInference.CstLinProHermite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CstLinProHermite &lt;: Basis</code></pre><p>The basis composed of the constant function, the identity, and probabilistic Hermite functions</p><p><strong>Fields</strong></p><ul><li><code>m::Int64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/basis.jl#L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.CstPhyHermite" href="#TransportBasedInference.CstPhyHermite"><code>TransportBasedInference.CstPhyHermite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CstPhyHermite &lt;: Basis</code></pre><p>The basis composed of the constant function and physicist Hermite functions</p><p><strong>Fields</strong></p><ul><li><code>m::Int64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/basis.jl#L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.CstProHermite" href="#TransportBasedInference.CstProHermite"><code>TransportBasedInference.CstProHermite</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct CstProHermite &lt;: Basis</code></pre><p>The basis composed of the constant function and probabilistic Hermite functions</p><p><strong>Fields</strong></p><ul><li><code>m::Int64</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/basis.jl#L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.ExpandedFunction" href="#TransportBasedInference.ExpandedFunction"><code>TransportBasedInference.ExpandedFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct ExpandedFunction</code></pre><p><code>ExpandedFunction</code> decomposes a multi-dimensional function f:R^{Nx} → R onto a basis of <code>MultiFunction</code> ψ<em>α where c</em>α are scalar coefficients for each MultiFunction: f(x1, x2, ..., xNx) = ∑<em>α c</em>α ψ_α(x1, x2, ..., xNx), where <code>Nψ</code> is the number of <code>MultiFunction</code>s used, and <code>Nx</code> is the dimension of the input vector <code>x</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>m::Int64</code></p></li><li><p><code>Nψ::Int64</code></p></li><li><p><code>Nx::Int64</code></p></li><li><p><code>B::MultiBasis</code></p></li><li><p><code>idx::Array{Int64,2}</code></p></li><li><p><code>dim::Array{Int64,1}</code></p></li><li><p><code>coeff::Array{Float64,1}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/expandedfunction.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.Hermite" href="#TransportBasedInference.Hermite"><code>TransportBasedInference.Hermite</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Hermite</p><p>An abstract type for 1D Hermite polynomials and functions</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitefunction/hermite.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.HermiteMap" href="#TransportBasedInference.HermiteMap"><code>TransportBasedInference.HermiteMap</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct HermiteMap</code></pre><p><strong>Fields</strong></p><ul><li><p><code>m::Int64</code></p></li><li><p><code>Nx::Int64</code></p></li><li><p><code>L::LinearTransform</code></p></li><li><p><code>C::Array{HermiteMapComponent,1}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/hermitemap.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.HermiteMapComponent" href="#TransportBasedInference.HermiteMapComponent"><code>TransportBasedInference.HermiteMapComponent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct HermiteMapComponent</code></pre><p><strong>Fields</strong></p><ul><li><p><code>m::Int64</code></p></li><li><p><code>Nψ::Int64</code></p></li><li><p><code>Nx::Int64</code></p></li><li><p><code>I::IntegratedFunction</code></p></li><li><p><code>α::Float64</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/hermitemapcomponent.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.IdFilter" href="#TransportBasedInference.IdFilter"><code>TransportBasedInference.IdFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IdFilter &lt;: SeqFilter</code></pre><p>An immutable structure for the identity filter.</p><p><strong>Fields</strong></p><ul><li><code>Δtdyn::Float64</code>: time-step of the dynamical model</li><li><code>Δtobs::Float64</code>: time-step between two observations</li></ul><p><strong>Constructors</strong></p><ul><li><code>IdFilter(Δtdyn, Δtobs)</code>: set up an identity filter</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/seqfilter.jl#L11-L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.IdFilter-Tuple{Any,Any,Any}" href="#TransportBasedInference.IdFilter-Tuple{Any,Any,Any}"><code>TransportBasedInference.IdFilter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(filter::IdFilter)(X, ystar, t)

Applies the identity transformation to the ensemble `X`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/seqfilter.jl#L34-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.IdentityInflation" href="#TransportBasedInference.IdentityInflation"><code>TransportBasedInference.IdentityInflation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">IdentityInflation &lt;: InflationType</code></pre><p>An type to store identity inflation :</p><p>Define additive inflation: x &lt;- x</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/inflation.jl#L31-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.IdentityInflation-Tuple{Any}" href="#TransportBasedInference.IdentityInflation-Tuple{Any}"><code>TransportBasedInference.IdentityInflation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    (A::IdentityInflation)(X)</code></pre><p>Apply an <code>IdentityInflation</code> <code>A</code> on an ensemble matrix <code>X</code>, i.e. xⁱ -&gt; xⁱ</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/inflation.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.InflationType" href="#TransportBasedInference.InflationType"><code>TransportBasedInference.InflationType</code></a> — <span class="docstring-category">Type</span></header><section><div><p><strong>InflationType</strong></p><p><strong></strong></p><p><strong>An abstract type for Inflation.</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/inflation.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.IntegratedFunction" href="#TransportBasedInference.IntegratedFunction"><code>TransportBasedInference.IntegratedFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct IntegratedFunction</code></pre><p>An immutable structure to hold the integrated function with <code>g</code> a <code>Rectifier</code> and <code>f</code> an <code>ExpandedFunction</code>.</p><p><strong>Fields</strong></p><ul><li><p><code>m::Int64</code></p></li><li><p><code>Nψ::Int64</code></p></li><li><p><code>Nx::Int64</code></p></li><li><p><code>g::Rectifier</code></p></li><li><p><code>f::ExpandedFunction</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/integratedfunction.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.InvPreconditioner" href="#TransportBasedInference.InvPreconditioner"><code>TransportBasedInference.InvPreconditioner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InvPreconditioner</code></pre><p>An immutable structure to hold the inverse of the preconditioner. For instance, this structure can be used to hold the estimate of the inverse of the Hessian in the BFGS algorithm.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/precond.jl#L30-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.LinHermiteMapComponent" href="#TransportBasedInference.LinHermiteMapComponent"><code>TransportBasedInference.LinHermiteMapComponent</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct LinHermiteMapComponent</code></pre><p><code>LinHermiteMapComponent</code> is a type to hold  the composition of a <code>LinearTransform</code>: a linear transformation that rescales the samples to get zero mean and unitary standard deviation component-wise and  an <code>HermiteMapComponent</code> element.</p><p><strong>Fields</strong></p><ul><li><p><code>L::LinearTransform</code></p></li><li><p><code>C::HermiteMapComponent</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/linhermitemapcomponent.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.LinearTransform" href="#TransportBasedInference.LinearTransform"><code>TransportBasedInference.LinearTransform</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LinearTransform</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/transform.jl#L9-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.Model" href="#TransportBasedInference.Model"><code>TransportBasedInference.Model</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">    Model</code></pre><p>A structure to perform the twin-experiment</p><p><strong>Fields</strong></p><ul><li><code>Nx</code> : Dimension of the state variable</li><li><code>Ny</code> : Dimension of the observation variable</li><li><code>Δtdyn</code> : Time-step for the dynamical model</li><li><code>Δtobs</code> : Time step between two observations of the state</li><li><code>ϵx</code> : Process noise</li><li><code>ϵy</code> : Observation noise</li><li><code>π0</code> : Multivariate distribution for the initial condition</li><li><code>Tburn</code> : Number of steps to burn from the end of the spin up to compute the metrics</li><li><code>Tstep</code> : Number of steps for which the filter to be tested is applied</li><li><code>Tspinup</code> : Number of steps of spin-up phase,  i.e. number of steps to generate the initial ensemble for the filtering algorithms</li><li><code>F</code> : State-Space Model</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/model.jl#L3-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.MultiAddInflation" href="#TransportBasedInference.MultiAddInflation"><code>TransportBasedInference.MultiAddInflation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MultiAddInflation &lt;: InflationType</code></pre><p>An type to store multiplico-additive inflation :</p><p>Define multiplico-additive inflation: xⁱ -&gt; x̄ + β*(xⁱ - x̄)  + ϵⁱ with ϵⁱ ∼ α and β a scalar</p><p><strong>Fields:</strong></p><ul><li><code>Nx</code> : dimension of the vector</li><li>&#39;β&#39; : Multiplicative inflation factor</li><li>&#39;α&#39; : Distribution of the additive inflation</li></ul><p><strong>Constructors:</strong></p><ul><li><code>MultiAddInflation(Nx::Int64, β::Real, α::ContinuousMultivariateDistribution)</code></li><li><code>MultiAddInflation(Nx::Int64, β::Float64, m::Array{Float64,1}, Σ)</code></li><li><code>MultiAddInflation(Nx::Int64, β::Float64, m::Array{Float64,1}, σ::Array{Float64,1})</code></li><li><code>MultiAddInflation(Nx::Int64, β::Float64, m::Array{Float64,1}, σ::Float64)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/inflation.jl#L211-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.MultiAddInflation-Tuple{Any,Int64,Int64}" href="#TransportBasedInference.MultiAddInflation-Tuple{Any,Int64,Int64}"><code>TransportBasedInference.MultiAddInflation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    (A::MultiAddInflation)(X, start::Int64, final::Int64)</code></pre><p>Apply the multiplicat inflation <code>A</code> to the lines <code>start</code> to <code>final</code> of an ensemble matrix <code>X</code>, i.e. xⁱ -&gt; x̄ + β*(xⁱ - x̄)  + ϵⁱ with ϵⁱ ∼ <code>A.α</code> and β a scalar, usually ∼ 1.0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/inflation.jl#L288-L294">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.MultiAddInflation-Tuple{Any}" href="#TransportBasedInference.MultiAddInflation-Tuple{Any}"><code>TransportBasedInference.MultiAddInflation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    (A::MultiAddInflation)(X, start::Int64, final::Int64)</code></pre><p>Apply the multiplico-additive inflation <code>A</code> to the ensemble matrix <code>X</code>, i.e. xⁱ -&gt; x̄ + β*(xⁱ - x̄)  + ϵⁱ with ϵⁱ ∼ <code>A.α</code> and β a scalar, usually ∼ 1.0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/inflation.jl#L305-L311">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.MultiBasis" href="#TransportBasedInference.MultiBasis"><code>TransportBasedInference.MultiBasis</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct MultiBasis</code></pre><p>An immutable structure to hold the Nx-cartesian product of the 1D basis of functions B MultiB = B × B× ... × B (Nx elements). The basis B contains m elements.</p><p><strong>Fields</strong></p><ul><li><p><code>B::Basis</code></p></li><li><p><code>Nx::Int64</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/multibasis.jl#L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.MultiFunction" href="#TransportBasedInference.MultiFunction"><code>TransportBasedInference.MultiFunction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct MultiFunction</code></pre><p>An immutable structure to hold an elementary function F: Rᵏ → R that can be decomposed as the product of univariate basis, where each basis is finite and contains constant and/or linear and Hermite functions F(x<em>1, x</em>2, ..., x<em>k) = f</em>1(x<em>1) × f</em>2(x<em>2) × ... × f</em>M(x_k)</p><p><strong>Fields</strong></p><ul><li><p><code>m::Int64</code></p></li><li><p><code>Nx::Int64</code></p></li><li><p><code>B::MultiBasis</code></p></li><li><p><code>α::Array{Int64,1}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/multifunction.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.MultiplicativeInflation" href="#TransportBasedInference.MultiplicativeInflation"><code>TransportBasedInference.MultiplicativeInflation</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MultiplicativeInflation &lt;: InflationType</code></pre><p>An type to store multiplicative inflation :</p><p>xⁱ -&gt; xⁱ + β*(xⁱ - x̄) with β a scalar</p><p><strong>Fields:</strong></p><ul><li>&#39;β&#39; : multiplicative inflation factor</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/inflation.jl#L169-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.MultiplicativeInflation-Tuple{Any,Int64,Int64}" href="#TransportBasedInference.MultiplicativeInflation-Tuple{Any,Int64,Int64}"><code>TransportBasedInference.MultiplicativeInflation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    (A::MultiplicativeInflation)(X, start::Int64, final::Int64)</code></pre><p>Apply the multiplicative inflation <code>A</code> to the lines <code>start</code> to <code>final</code> of an ensemble matrix <code>X</code>, i.e. xⁱ -&gt; x̄ + β*(xⁱ - x̄)  with β scalar, usually ∼ 1.0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/inflation.jl#L184-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.MultiplicativeInflation-Tuple{Any}" href="#TransportBasedInference.MultiplicativeInflation-Tuple{Any}"><code>TransportBasedInference.MultiplicativeInflation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">    (A::MultiplicativeInflation)(X)</code></pre><p>Apply the multiplicative inflation <code>A</code> to an ensemble matrix <code>X</code>, i.e. xⁱ -&gt; x̄ + β*(xⁱ - x̄)  with β scalar, usually ∼ 1.0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/inflation.jl#L201-L207">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.Parallel" href="#TransportBasedInference.Parallel"><code>TransportBasedInference.Parallel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Parallel</code></pre><p>An abstract type for the different kinds of parallel programming supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/parallel.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.PhyHermite" href="#TransportBasedInference.PhyHermite"><code>TransportBasedInference.PhyHermite</code></a> — <span class="docstring-category">Type</span></header><section><div><p>PhyHermite &lt;: Hermite</p><p>An immutable structure for physicist Hermite functions defined as ψm(x) = Hm(x)*exp(-x^2/2).</p><p><strong>Fields</strong></p><ul><li><code>m</code> : order of the function</li><li><code>Poly</code> : physicist Hermite polynomial of order m</li><li><code>scaled</code> : with rescaling to have unitary norm</li></ul><p><strong>Constructors</strong></p><ul><li><code>PhyHermite(m, Poly, scaled)</code></li><li><code>PhyHermite(m; scaled = false)</code>`</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitefunction/phyhermite.jl#L10-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.PhyPolyHermite" href="#TransportBasedInference.PhyPolyHermite"><code>TransportBasedInference.PhyPolyHermite</code></a> — <span class="docstring-category">Type</span></header><section><div><p>PhyPolyHermite &lt;: Hermite</p><p>An immutable structure for physicist Hermite polynomials</p><p><strong>Fields</strong></p><ul><li><code>m</code> : order of the polynomial</li><li><code>P</code> : physicist Hermite polynomial of order m</li><li><code>scaled</code> : with rescaling to have unitary norm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitefunction/phypolyhermite.jl#L11-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.ProHermite" href="#TransportBasedInference.ProHermite"><code>TransportBasedInference.ProHermite</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ProHermite &lt;: Hermite</p><p>An immutable structure for probabilistic Hermite functions defined as ψem(x) = Hem(x)*exp(-x^2/4).</p><p><strong>Fields</strong></p><ul><li><code>m</code> : order of the function</li><li><code>Poly</code> : probabilistic Hermite polynomial of order m</li><li><code>scaled</code> : with rescaling to have unitary norm</li></ul><p><strong>Constructors</strong></p><ul><li><code>ProHermite(m, Poly, scaled)</code></li><li><code>ProHermite(m; scaled = false)</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitefunction/prohermite.jl#L13-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.ProPolyHermite" href="#TransportBasedInference.ProPolyHermite"><code>TransportBasedInference.ProPolyHermite</code></a> — <span class="docstring-category">Type</span></header><section><div><p>ProPolyHermite &lt;: Hermite</p><p>An immutable structure for probabilistic Hermite polynomials</p><p><strong>Fields</strong></p><ul><li><code>m</code> : order of the polynomial</li><li><code>P</code> : probabilistic Hermite polynomial of order m</li><li><code>scaled</code> : with rescaling to have unitary norm</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitefunction/propolyhermite.jl#L8-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.Rectifier" href="#TransportBasedInference.Rectifier"><code>TransportBasedInference.Rectifier</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Rectifier</code></pre><p>This structure defines a continuous rectifier g, i.e. a positive and monotonically increasing function (e.g. square function, exponential , softplus, explinearunit).</p><p><strong>Fields</strong></p><ul><li><code>T::String</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/rectifier.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.SeqFilter" href="#TransportBasedInference.SeqFilter"><code>TransportBasedInference.SeqFilter</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SeqFilter</code></pre><p>An abstract type for the ensemble filtering algorithms.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/seqfilter.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.Serial" href="#TransportBasedInference.Serial"><code>TransportBasedInference.Serial</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Serial &lt;: Parallel</code></pre><p>A type for serial computing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/parallel.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.StateSpace" href="#TransportBasedInference.StateSpace"><code>TransportBasedInference.StateSpace</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct StateSpace</code></pre><p>An immutable structure representing the dynamical <code>f</code> and observation <code>h</code> operators. The dynamical model is provided by the right hand side of the ODE to solve. For a system of ODEs, we will prefer an in-place syntax <code>f(du, u, p, t)</code>, where <code>p</code> are parameters of the model. We rely on <code>OrdinaryDiffEq</code> to integrate the dynamical system with the Tsitouras 5/4 Runge-Kutta method adaptive time marching. <code>h</code> must be a function of the form <code>h(u, t)</code>, where <code>u</code> is the state vector and <code>t</code> is the time.</p><p><strong>Fields</strong></p><ul><li><p><code>f::Function</code></p><p>Propagatation f</p></li><li><p><code>h::Function</code></p><p>Observation h</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/statespace/system.jl#L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.Storage" href="#TransportBasedInference.Storage"><code>TransportBasedInference.Storage</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Storage</code></pre><p>An immutable structure to hold the evaluation of basis functions</p><p><strong>Fields</strong></p><ul><li><p><code>m::Int64</code></p></li><li><p><code>Nψ::Int64</code></p></li><li><p><code>Nx::Int64</code></p></li><li><p><code>f::ExpandedFunction</code></p></li><li><p><code>ψoff::Array{Float64,2}</code></p></li><li><p><code>ψoffψd::Array{Float64,2}</code></p></li><li><p><code>ψoffψd0::Array{Float64,2}</code></p></li><li><p><code>ψoffdψxd::Array{Float64,2}</code></p></li><li><p><code>ψnorm::Array{Float64,1}</code></p></li><li><p><code>cache_dcψxdt::Array{Float64,2}</code></p></li><li><p><code>cache_gradxd::Array{Float64,2}</code></p></li><li><p><code>cache_dψxd::Array{Float64,1}</code></p></li><li><p><code>cache_integral::Array{Float64,1}</code></p></li><li><p><code>cache_g::Array{Float64,1}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/hermitemap/storage.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.SyntheticData" href="#TransportBasedInference.SyntheticData"><code>TransportBasedInference.SyntheticData</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SyntheticData</code></pre><p>A structure to store the synthetic data in a twin-experiment</p><p><strong>Fields</strong></p><ul><li><code>tt</code> : time history</li><li><code>x0</code> : the initial condition</li><li><code>xt</code> : history of the state</li><li><code>yt</code> : history of the observations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/DA/model.jl#L54-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="TransportBasedInference.Thread" href="#TransportBasedInference.Thread"><code>TransportBasedInference.Thread</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Thread &lt;: Parallel</code></pre><p>A type for multi-threaded computing</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/5821ee6604e03a4647ef981313f9d5b7f9dc66cb/src/tools/parallel.jl#L17-L21">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#TransportBasedInference.AdditiveInflation-Tuple{Any,Int64,Int64}"><code>TransportBasedInference.AdditiveInflation</code></a></li><li><a href="#TransportBasedInference.AdditiveInflation-Tuple{Array{Float64,1}}"><code>TransportBasedInference.AdditiveInflation</code></a></li><li><a href="#TransportBasedInference.AdditiveInflation-Tuple{Any}"><code>TransportBasedInference.AdditiveInflation</code></a></li><li><a href="#TransportBasedInference.Basis"><code>TransportBasedInference.Basis</code></a></li><li><a href="#TransportBasedInference.CstLinPhyHermite"><code>TransportBasedInference.CstLinPhyHermite</code></a></li><li><a href="#TransportBasedInference.CstLinProHermite"><code>TransportBasedInference.CstLinProHermite</code></a></li><li><a href="#TransportBasedInference.CstPhyHermite"><code>TransportBasedInference.CstPhyHermite</code></a></li><li><a href="#TransportBasedInference.CstProHermite"><code>TransportBasedInference.CstProHermite</code></a></li><li><a href="#TransportBasedInference.ExpandedFunction"><code>TransportBasedInference.ExpandedFunction</code></a></li><li><a href="#TransportBasedInference.Hermite"><code>TransportBasedInference.Hermite</code></a></li><li><a href="#TransportBasedInference.HermiteMap"><code>TransportBasedInference.HermiteMap</code></a></li><li><a href="#TransportBasedInference.HermiteMapComponent"><code>TransportBasedInference.HermiteMapComponent</code></a></li><li><a href="#TransportBasedInference.IdFilter"><code>TransportBasedInference.IdFilter</code></a></li><li><a href="#TransportBasedInference.IdFilter-Tuple{Any,Any,Any}"><code>TransportBasedInference.IdFilter</code></a></li><li><a href="#TransportBasedInference.IdentityInflation"><code>TransportBasedInference.IdentityInflation</code></a></li><li><a href="#TransportBasedInference.IdentityInflation-Tuple{Any}"><code>TransportBasedInference.IdentityInflation</code></a></li><li><a href="#TransportBasedInference.InflationType"><code>TransportBasedInference.InflationType</code></a></li><li><a href="#TransportBasedInference.IntegratedFunction"><code>TransportBasedInference.IntegratedFunction</code></a></li><li><a href="#TransportBasedInference.InvPreconditioner"><code>TransportBasedInference.InvPreconditioner</code></a></li><li><a href="#TransportBasedInference.LinHermiteMapComponent"><code>TransportBasedInference.LinHermiteMapComponent</code></a></li><li><a href="#TransportBasedInference.LinearTransform"><code>TransportBasedInference.LinearTransform</code></a></li><li><a href="#TransportBasedInference.Model"><code>TransportBasedInference.Model</code></a></li><li><a href="#TransportBasedInference.MultiAddInflation-Tuple{Any}"><code>TransportBasedInference.MultiAddInflation</code></a></li><li><a href="#TransportBasedInference.MultiAddInflation"><code>TransportBasedInference.MultiAddInflation</code></a></li><li><a href="#TransportBasedInference.MultiAddInflation-Tuple{Any,Int64,Int64}"><code>TransportBasedInference.MultiAddInflation</code></a></li><li><a href="#TransportBasedInference.MultiBasis"><code>TransportBasedInference.MultiBasis</code></a></li><li><a href="#TransportBasedInference.MultiFunction"><code>TransportBasedInference.MultiFunction</code></a></li><li><a href="#TransportBasedInference.MultiplicativeInflation-Tuple{Any,Int64,Int64}"><code>TransportBasedInference.MultiplicativeInflation</code></a></li><li><a href="#TransportBasedInference.MultiplicativeInflation-Tuple{Any}"><code>TransportBasedInference.MultiplicativeInflation</code></a></li><li><a href="#TransportBasedInference.MultiplicativeInflation"><code>TransportBasedInference.MultiplicativeInflation</code></a></li><li><a href="#TransportBasedInference.Parallel"><code>TransportBasedInference.Parallel</code></a></li><li><a href="#TransportBasedInference.PhyHermite"><code>TransportBasedInference.PhyHermite</code></a></li><li><a href="#TransportBasedInference.PhyPolyHermite"><code>TransportBasedInference.PhyPolyHermite</code></a></li><li><a href="#TransportBasedInference.ProHermite"><code>TransportBasedInference.ProHermite</code></a></li><li><a href="#TransportBasedInference.ProPolyHermite"><code>TransportBasedInference.ProPolyHermite</code></a></li><li><a href="#TransportBasedInference.Rectifier"><code>TransportBasedInference.Rectifier</code></a></li><li><a href="#TransportBasedInference.SeqFilter"><code>TransportBasedInference.SeqFilter</code></a></li><li><a href="#TransportBasedInference.Serial"><code>TransportBasedInference.Serial</code></a></li><li><a href="#TransportBasedInference.StateSpace"><code>TransportBasedInference.StateSpace</code></a></li><li><a href="#TransportBasedInference.Storage"><code>TransportBasedInference.Storage</code></a></li><li><a href="#TransportBasedInference.SyntheticData"><code>TransportBasedInference.SyntheticData</code></a></li><li><a href="#TransportBasedInference.Thread"><code>TransportBasedInference.Thread</code></a></li><li><a href="#Base.size-Tuple{MultiAddInflation}"><code>Base.size</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},ExpandedFunction}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},HermiteMap}"><code>RecipesBase.apply_recipe</code></a></li><li><a href="#TransportBasedInference.DPhyPolyHermite-Tuple{Int64}"><code>TransportBasedInference.DPhyPolyHermite</code></a></li><li><a href="#TransportBasedInference.Diff-Tuple{Any,Any}"><code>TransportBasedInference.Diff</code></a></li><li><a href="#TransportBasedInference.Diff-Tuple{Any}"><code>TransportBasedInference.Diff</code></a></li><li><a href="#TransportBasedInference.allequal-Tuple{Any,Any}"><code>TransportBasedInference.allequal</code></a></li><li><a href="#TransportBasedInference.bisection-NTuple{6,Any}"><code>TransportBasedInference.bisection</code></a></li><li><a href="#TransportBasedInference.clenshaw_curtis-Tuple{Int64}"><code>TransportBasedInference.clenshaw_curtis</code></a></li><li><a href="#TransportBasedInference.csne-Union{Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,2},Array{T,1}}} where T"><code>TransportBasedInference.csne</code></a></li><li><a href="#TransportBasedInference.degree-Tuple{PhyHermite}"><code>TransportBasedInference.degree</code></a></li><li><a href="#TransportBasedInference.elementproductmatmul!-Tuple{Array{Float64,1},Array{Float64,2},Array{Float64,2},Array{Float64,1}}"><code>TransportBasedInference.elementproductmatmul!</code></a></li><li><a href="#TransportBasedInference.exactn-Tuple{Any}"><code>TransportBasedInference.exactn</code></a></li><li><a href="#TransportBasedInference.fact2-Tuple{Int64}"><code>TransportBasedInference.fact2</code></a></li><li><a href="#TransportBasedInference.grad_x_logeval-Union{Tuple{T}, Tuple{Rectifier,T}} where T&lt;:Real"><code>TransportBasedInference.grad_x_logeval</code></a></li><li><a href="#TransportBasedInference.gradlog_pdf-Tuple{Any}"><code>TransportBasedInference.gradlog_pdf</code></a></li><li><a href="#TransportBasedInference.greedyfit-Tuple{Int64,Int64,Int64,AbstractArray{Float64,2},AbstractArray{Float64,2},Int64,Float64,Float64,Float64}"><code>TransportBasedInference.greedyfit</code></a></li><li><a href="#TransportBasedInference.greedyfit-Tuple{Int64,Int64,Any,Int64}"><code>TransportBasedInference.greedyfit</code></a></li><li><a href="#TransportBasedInference.greedyfit-Tuple{Int64,Int64,Int64,AbstractArray{Float64,2},Int64,Float64,Float64,Float64}"><code>TransportBasedInference.greedyfit</code></a></li><li><a href="#TransportBasedInference.greedyfit-Tuple{Int64,Int64,Any,Any,Int64}"><code>TransportBasedInference.greedyfit</code></a></li><li><a href="#TransportBasedInference.hesslog_pdf-Tuple{Any}"><code>TransportBasedInference.hesslog_pdf</code></a></li><li><a href="#TransportBasedInference.log_pdf-Tuple{Any}"><code>TransportBasedInference.log_pdf</code></a></li><li><a href="#TransportBasedInference.log_pdf_banana-Tuple{AbstractArray{T,1} where T}"><code>TransportBasedInference.log_pdf_banana</code></a></li><li><a href="#TransportBasedInference.lorenz63!-NTuple{4,Any}"><code>TransportBasedInference.lorenz63!</code></a></li><li><a href="#TransportBasedInference.lorenz96!-NTuple{4,Any}"><code>TransportBasedInference.lorenz96!</code></a></li><li><a href="#TransportBasedInference.mean_hist-Tuple{Array{Array{Float64,2},1}}"><code>TransportBasedInference.mean_hist</code></a></li><li><a href="#TransportBasedInference.meas-Tuple{Any,Any,Any}"><code>TransportBasedInference.meas</code></a></li><li><a href="#TransportBasedInference.member-Tuple{Any,Any}"><code>TransportBasedInference.member</code></a></li><li><a href="#TransportBasedInference.observe-Tuple{StateSpace,Array{Float64,1},Float64}"><code>TransportBasedInference.observe</code></a></li><li><a href="#TransportBasedInference.observe-Tuple{Function,Any,Float64,Int64,Int64}"><code>TransportBasedInference.observe</code></a></li><li><a href="#TransportBasedInference.qraddrow-Union{Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,2}}} where T"><code>TransportBasedInference.qraddrow</code></a></li><li><a href="#TransportBasedInference.qrdelcol-Union{Tuple{T}, Tuple{AbstractArray{T,2},Int64}} where T"><code>TransportBasedInference.qrdelcol</code></a></li><li><a href="#TransportBasedInference.rdnortho-Tuple{Int64}"><code>TransportBasedInference.rdnortho</code></a></li><li><a href="#TransportBasedInference.rmse-Tuple{Array{Float64,1},Array{Float64,2}}"><code>TransportBasedInference.rmse</code></a></li><li><a href="#TransportBasedInference.sample_banana-Tuple{Any}"><code>TransportBasedInference.sample_banana</code></a></li><li><a href="#TransportBasedInference.seqassim-Tuple{StateSpace,SyntheticData,Int64,InflationType,SeqFilter,Any,Any,Any,Float64,Localization}"><code>TransportBasedInference.seqassim</code></a></li><li><a href="#TransportBasedInference.seqassim-Tuple{StateSpace,SyntheticData,Int64,InflationType,SeqFilter,Any,Any,Any,Float64}"><code>TransportBasedInference.seqassim</code></a></li><li><a href="#TransportBasedInference.spread-Tuple{Array{Float64,2}}"><code>TransportBasedInference.spread</code></a></li><li><a href="#TransportBasedInference.state-Tuple{Any,Any,Any}"><code>TransportBasedInference.state</code></a></li><li><a href="#TransportBasedInference.vander!-Tuple{Any,CstLinPhyHermite,Int64,Int64,Any}"><code>TransportBasedInference.vander!</code></a></li><li><a href="#TransportBasedInference.vander!-Tuple{Any,CstPhyHermite,Int64,Int64,Any}"><code>TransportBasedInference.vander!</code></a></li><li><a href="#TransportBasedInference.vander!-Tuple{Any,CstLinProHermite,Int64,Int64,Any}"><code>TransportBasedInference.vander!</code></a></li><li><a href="#TransportBasedInference.viewmeas-Tuple{Any,Any,Any}"><code>TransportBasedInference.viewmeas</code></a></li><li><a href="#TransportBasedInference.viewstate-Tuple{Any,Any,Any}"><code>TransportBasedInference.viewstate</code></a></li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/3.-Structure-discovery-of-the-Lorenz-96/">« 3. Structure discovery for the Lorenz-96 problem</a><a class="docs-footer-nextpage" href="../contribute/">Community guidelines »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 13 July 2021 21:16">Tuesday 13 July 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
