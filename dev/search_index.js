var documenterSearchIndex = {"docs":
[{"location":"manual/1.-Estimation-of-the-Banana-distribution/#.-Estimation-of-the-Banana-distribution","page":"-","title":"1. Estimation of the Banana distribution","text":"","category":"section"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"In this notebook, we will show how we can estimate a density pi given a limited number of samples boldsymbolx^i sim pi in mathbbR^N_x. We will rely on the adaptive estimation framework developed in Baptista et al. [1].","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"References:","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"[1] Baptista, R., Zahm, O., & Marzouk, Y. (2020). An adaptive transport framework for joint and conditional density estimation. arXiv preprint arXiv:2009.10303.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"[2] Marzouk, Y., Moselhy, T., Parno, M., & Spantini, A. (2016). Sampling via measure transport: An introduction. Handbook of uncertainty quantification, 1-41.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"using Plots\nusing PyPlot\ndefault(tickfont = font(\"CMU Serif\", 9),\n        titlefont = font(\"CMU Serif\", 14),\n        guidefont = font(\"CMU Serif\", 12),\n        legendfont = font(\"CMU Serif\", 10),\n        grid = false)\npyplot()\n\nusing LaTeXStrings\nPyPlot.rc(\"font\", family = \"CMU Serif\")\nPyPlot.matplotlib[:rc](\"mathtext\",fontset=\"cm\")        #computer modern font\nPyPlot.matplotlib[:rc](\"font\",family=\"serif\",size=12)\n\nusing ColorSchemes\nnothing #hide","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"using LinearAlgebra\nusing TransportBasedInference\nusing Statistics\nusing Distributions\nnothing #hide","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"Load some packages to make nice figures","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/#Problem-setup","page":"-","title":"Problem setup","text":"","category":"section"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"We start by generating N_e samples from a banana distribution using the function sample_banana.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"Ne = 500 # Number of samples\nNx = 2 # Dimension of the state\n\n# Define the parameters of the banana distribution\nμ = 0.0\nσ = 2.0\nbananicity = 0.3\n\n# Generate the samples\nX = sample_banana(Ne, μ = μ, σ = σ, bananicity = bananicity)\nnothing #hide","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"X is an ensemble matrix whose columns are the different ensemble members, i.e. boldsymbolX = left boldsymbolx^1 ldots boldsymbolx^N_e right  in mathbbR^N_x times N_e.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"Nlog = 100\nlogbanana = zeros(Nlog, Nlog)\n\nxrange = range(-6.0; stop = 6.0, length = Nlog)\nyrange = range(-4.0; stop = 6.0, length = Nlog)\n\nfor (i,x) in enumerate(xrange)\n    for (j,y) in enumerate(yrange)\n        logbanana[i,j] = log_pdf_banana([x;y]; μ = μ, σ = σ, bananicity = bananicity)\n    end\nend\n\n\ncontour(xrange, yrange, exp.(logbanana)', ratio = 1,\n         title = \"True density\",\n         colorbar = false, grid = false,\n         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),\n         xlim = (xrange[1], xrange[end]), ylim = (-Inf, Inf), linewidth = 3)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"We define an object S of  typeHermiteMapto hold the Knothe-Rosenblatt rearrangement that pushes forward pi to the reference density, i.e. the standard Gaussian distribution rho. The default constructor for an HermiteMap requires, where m is the maximal order of the Hermite polynomials considered in the expansion, N_x the dimension of the state, L a linear transformation that rescale the samples to get zero mean and unitary standard deviation component-wise, and C an array of N_x MapComponent.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"m = 30\nS = HermiteMap(m, X; diag = true, b = \"CstLinProHermite\")","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"The next step is to use the greedy algorithm developed by Baptista et al. (2020) to construct a sparse expansion of the different components of the map S. Depending on the accuracy of the amp required. Several options are possible for the optimization:","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"kfold uses a k-fold cross validation procedure (the more robust choice)\nsplit splits the set of samples into a training and a testing\nAn Int64 to determine the maximum number of features for each component s^k of the map S\nnothing to simply optimize the existing coefficients in the basis expansion.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"optimize(S, X, \"kfold\"; withqr = true)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"The map S is an approximation of the pushforward of the target density pi, to the standard Gaussian density rho.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"We can access the different components of the map S as follows:","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"S[1]","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"S[2]","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"We can access the coefficients of the expansion for each map component with getcoeff.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"getcoeff(S[2])","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"plot(S[2].I.f)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"getidx can be used to obtain the active features of the different map components. The number of columns is the number of dimensions. Each line correspond to a multi-index for the different components.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"getidx(S[2])","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"Using PlotRecipes.jl, we plot the number of occurences of each variable (columns) in each map component (rows).","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"plot(S)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"By setting degree = true, we plot maximum multi-index of the features identified for each variable (columns) in each map component (rows)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"plot(S; degree = true)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"We can now compare the log-density of the true Banana density with the approximated one. Let's create a grid and evaluate the logpdf the densities.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"logbanana_approx = zeros(Nlog, Nlog)\nlognormal = zeros(Nlog, Nlog)\n\nfor (i,x) in enumerate(xrange)\n    for (j,y) in enumerate(yrange)\n        logbanana_approx[i,j] = log_pdf(S, reshape([x; y], (2,1)))[1]\n        lognormal[i,j] = logpdf(MvNormal(zeros(2), 1.0), [x;y])\n    end\nend\n\nplt = plot(layout = grid(1, 2), colorbar = false, grid = false)\ncontour!(plt[1,1], xrange, yrange, exp.(logbanana)', ratio = 1,\n         title = \"True density\",\n         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),\n         xlim = (xrange[1], xrange[end]), ylim = (-Inf, Inf), linewidth = 3)\n\ncontour!(plt[1,2], xrange, yrange, exp.(logbanana_approx)', ratio = 1,\n         title = \"ATM approximate\",\n         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),\n         xlim = (xrange[1], xrange[end]), ylim = (-Inf, Inf), linewidth = 3)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"We can overlap the estimated density with the samples","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"contour(xrange, yrange, exp.(logbanana_approx)', ratio = 1, colorbar = false,\n         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),\n         xlim = (-Inf, Inf), ylim = (-Inf, Inf), linewidth = 3)\nscatter!(X[1,:], X[2,:]; legend = false, color = :purple3, ratio = 1, markersize = 6)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"By definition, the map S pushes forward the samples boldsymbolx^i to the standard normal distribution rho of mathbbR^2, denoted boldsymbolS_sharp pi = rho,  i.e. boldsymbolx^i sim pi Rightarrow boldsymbolS(boldsymbolx^i) sim rho.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"SpushX = evaluate(S, X)\n\ncontour(xrange, yrange, exp.(lognormal)', ratio = 1, colorbar = false,\n         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),\n         xlim = (-Inf, Inf), ylim = (-Inf, Inf), linewidth = 3)\nscatter!(SpushX[1,:], SpushX[2,:]; legend = false, color = :purple3, ratio = 1, markersize = 6)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"We can compute the statistics of the pushed samples","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"mean(SpushX; dims = 2)[:,1] # close to zero","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"cov(SpushX; dims = 2) # close to the identity matrix","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"We can use the map boldsymbolS to generate new samples from the target density pi. The map boldsymbolS pulls back  samples boldsymbolz^i of the standard normal distribution rho to the target density pi, denoted boldsymbolS^sharp rho = pi, i.e. boldsymbolz^i sim rho Rightarrow boldsymbolS^-1(boldsymbolz^i) sim pi.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"Znew = randn(Nx, Ne)\nXnew = zeros(Nx, Ne)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"We use the in-place routine inverse to solve the triangular system boldsymbolS(boldsymbolx^i) = boldsymbolz^i for boldsymbolx^i in mathbbR^N_x for the different samples. From the lower triangular structure of boldsymbolS, this inversion reduces to a sequence of one dimensional root finding problems Marzouk et al. [2].","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"inverse!(Xnew, copy(Znew), S)\nevaluate(S, Xnew)-Znew","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"-","title":"-","text":"plt = plot(layout = grid(1, 2))\n\ncontour!(plt[1,1], xrange, yrange, exp.(lognormal)', ratio = 1, colorbar = false,\n         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),\n         xlim = (xrange[1], xrange[end]), ylim = (yrange[1], yrange[end]), linewidth = 3)\nscatter!(plt[1,1], Znew[1,:], Znew[2,:]; legend = false, color = :purple3, ratio = 1, markersize = 6,\n         title = L\"z^i \\sim \\rho\")\n\ncontour!(plt[1,2], xrange, yrange, exp.(logbanana)', ratio = 1, colorbar = false,\n         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),\n         xlim = (xrange[1], xrange[end]), ylim = (yrange[1], yrange[end]), linewidth = 3)\nscatter!(plt[1,2], Xnew[1,:], Xnew[2,:]; legend = false, color = :purple3, ratio = 1, markersize = 6,\n            title = L\"S^{-1}(z^i) \\sim S^{\\sharp}\\rho\")","category":"page"},{"location":"manual/functions/#Functions-and-types","page":"Functions and types","title":"Functions and types","text":"","category":"section"},{"location":"manual/functions/#Functions","page":"Functions and types","title":"Functions","text":"","category":"section"},{"location":"manual/functions/","page":"Functions and types","title":"Functions and types","text":"Modules = [TransportBasedInference]\nOrder   = [:function]","category":"page"},{"location":"manual/functions/#Base.size-Tuple{MultiAddInflation}","page":"Functions and types","title":"Base.size","text":"size(A::MultiAddInflation)\n\nReturn the dimension of the additive inflation of A.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},ExpandedFunction}","page":"Functions and types","title":"RecipesBase.apply_recipe","text":"    heatmap(M::HermiteMap; start::Int64=1, color, degree)\n\nPlot recipe for an ExpandedFunction.  We can either plot the number of occurences of each variable (columns) in each map component (rows) if degree = false (default behavior), or the maximum multi-index of the features identified for each variable (columns) in each map component (rows) if degree = true.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},HermiteMap}","page":"Functions and types","title":"RecipesBase.apply_recipe","text":"    heatmap(M::HermiteMap; start::Int64=1, color, degree)\n\nPlot recipe for an HermiteMap. We can either plot the number of occurences of each variable (columns) in each map component (rows) if degree = false (default behavior), or the maximum multi-index of the features identified for each variable (columns) in each map component (rows) if degree = true.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.DPhyPolyHermite-Tuple{Int64}","page":"Functions and types","title":"TransportBasedInference.DPhyPolyHermite","text":"\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.Diff-Tuple{Any,Any}","page":"Functions and types","title":"TransportBasedInference.Diff","text":"Diff(f,k)\n\nBy recurrence, create the k-th derivative of the scalar function f, based on ForwardDiff.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.Diff-Tuple{Any}","page":"Functions and types","title":"TransportBasedInference.Diff","text":"Diff(f)\n\nCreate the derivative of the scalar function f, based on ForwardDiff.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.allequal-Tuple{Any,Any}","page":"Functions and types","title":"TransportBasedInference.allequal","text":"allequal(x, r)\n\nA function to verify that all the entries of the vector x are equal to r\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.clenshaw_curtis-Tuple{Int64}","page":"Functions and types","title":"TransportBasedInference.clenshaw_curtis","text":"clenshaw_curtis(N)\n\nCompute the nodes x and weights w for integrating a continuous functions from [-1,1] using the Clenshaw-Curtis integration rule with order N.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.csne-Union{Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,2},Array{T,1}}} where T","page":"Functions and types","title":"TransportBasedInference.csne","text":"Solve the corrected semi-normal equations R'Rx=A'b.\n\nx, r = csne(R, A, b) solves the least-squares problem\n\nminimize  ||r||_2,  where  r := b - A*x\n\nusing the corrected semi-normal equation approach described by Bjork (1987). Assumes that R is upper triangular.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.degree-Tuple{PhyHermite}","page":"Functions and types","title":"TransportBasedInference.degree","text":"    degree(P)\n\nReturn the degree of P\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.elementproductmatmul!-Tuple{Array{Float64,1},Array{Float64,2},Array{Float64,2},Array{Float64,1}}","page":"Functions and types","title":"TransportBasedInference.elementproductmatmul!","text":"elementproductmatmul!(d, A, B, c)\n\nCompute in-place the product (A ∘ B)*c, where ∘ denotes the element-wise  product of two matrices.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.exactn-Tuple{Any}","page":"Functions and types","title":"TransportBasedInference.exactn","text":"    exactn(N)\n\nA function to create a 1D sample with exactly mean 0 and covariance 1 (The samples are no longer i.i.d but this can be usueful when the initialization of the problem is challenging.)\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.fact2-Tuple{Int64}","page":"Functions and types","title":"TransportBasedInference.fact2","text":"fact2(n)\n\nCompute the double factorial of n, i.e. the product of the odd (if n is odd) or even (if n is even) numbers up to n.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.gradlog_pdf-Tuple{Any}","page":"Functions and types","title":"TransportBasedInference.gradlog_pdf","text":"gradlog_pdf(x)\n\nCompute the gradient of the log of the density of the univariate standard Gaussian distribution (zero mean and unitary standard deviation).\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.greedyfit-Tuple{Int64,Int64,Any,Any,Int64}","page":"Functions and types","title":"TransportBasedInference.greedyfit","text":"greedyfit(m::Int64, Nx::Int64, X, Xvalid, maxterms::Int64; withconstant, withqr, maxpatience, verbose, hessprecond) -> Tuple{HermiteMapComponent,Tuple{Array{Float64,1},Array{Float64,1}}}\n\n\nAn adaptive routine to estimate a sparse approximation of an HermiteMapComponent based on  the pair of ensemble matrices X (training set) and Xvalid (validation set).\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.greedyfit-Tuple{Int64,Int64,Any,Int64}","page":"Functions and types","title":"TransportBasedInference.greedyfit","text":"greedyfit(m::Int64, Nx::Int64, X, maxterms::Int64; withconstant, withqr, maxpatience, verbose, hessprecond) -> Tuple{HermiteMapComponent,Array{Float64,1}}\n\n\nAn adaptive routine to estimate a sparse approximation of an HermiteMapComponent based on  the ensemble matrix X.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.greedyfit-Tuple{Int64,Int64,Int64,AbstractArray{Float64,2},AbstractArray{Float64,2},Int64,Float64,Float64,Float64}","page":"Functions and types","title":"TransportBasedInference.greedyfit","text":"greedyfit(Nx::Int64, poff::Int64, pdiag::Int64, X::AbstractArray{Float64,2}, Xvalid::AbstractArray{Float64,2}, maxfamiliesoff::Int64, λ::Float64, δ::Float64, γ::Float64; maxpatience, verbose) -> Tuple{SparseRadialMapComponent,Tuple{Array{Float64,1},Array{Float64,1}}}\n\n\nAn adaptive routine to estimate a sparse approximation of an SparseRadialMapComponent based on  the pair of ensemble matrices X (training set) and Xvalid (validation set).\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.greedyfit-Tuple{Int64,Int64,Int64,AbstractArray{Float64,2},Int64,Float64,Float64,Float64}","page":"Functions and types","title":"TransportBasedInference.greedyfit","text":"greedyfit(Nx::Int64, poff::Int64, pdiag::Int64, X::AbstractArray{Float64,2}, maxfamiliesoff::Int64, λ::Float64, δ::Float64, γ::Float64; maxpatience, verbose) -> Tuple{SparseRadialMapComponent,Array{Float64,1}}\n\n\nAn adaptive routine to estimate a sparse approximation of an SparseRadialMapComponent based on  the ensemble matrix X.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.hesslog_pdf-Tuple{Any}","page":"Functions and types","title":"TransportBasedInference.hesslog_pdf","text":"hesslog_pdf(x)\n\nCompute the hessian of the log of the density of the univariate standard Gaussian distribution (zero mean and unitary standard deviation).\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.log_pdf-Tuple{Any}","page":"Functions and types","title":"TransportBasedInference.log_pdf","text":"log_pdf(x)\n\nCompute the log of the density of the univariate standard Gaussian distribution (zero mean and unitary standard deviation).\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.log_pdf_banana-Tuple{AbstractArray{T,1} where T}","page":"Functions and types","title":"TransportBasedInference.log_pdf_banana","text":"log_pdf_banana(X; μ = 0.0, σ = 2.0, bananicity = 0.2)\n\nCompute the logarithm of the porbability density function (pdf) of the Banana distribution at X. See documentation of sample_banana for details on the Banana distribution.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.lorenz63!-NTuple{4,Any}","page":"Functions and types","title":"TransportBasedInference.lorenz63!","text":"lorenz63!(du,u,p,t)\n\nCompute in-place the right-hand-side of the Lorenz-63 system for a state u at time t, and store it in du. p is vector of user-defined parameters.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.lorenz96!-NTuple{4,Any}","page":"Functions and types","title":"TransportBasedInference.lorenz96!","text":"lorenz96!(du,u,p,t)\n\nCompute in-place the right-hand-side of the Lorenz-96 system for a state u at time t, and store it in du. p is vector of user-defined parameters.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.mean_hist-Tuple{Array{Array{Float64,2},1}}","page":"Functions and types","title":"TransportBasedInference.mean_hist","text":"mean_hist(hist)\n\nStack together the mean of the different ensembles.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.meas-Tuple{Any,Any,Any}","page":"Functions and types","title":"TransportBasedInference.meas","text":"meas(X, Ny, Nx)\n\nA function to extract the first Ny lines of the ensemble matrix X, typically storing the observations.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.member-Tuple{Any,Any}","page":"Functions and types","title":"TransportBasedInference.member","text":"member(X, idx)\n\nExtract the idx ensemble member of the ensemble matrix X\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.observe-Tuple{Function,Any,Float64,Int64,Int64}","page":"Functions and types","title":"TransportBasedInference.observe","text":"observe(h::Function, X, t::Float64, Ny::Int64, Nx::Int64; P)\n\n\nEvaluate the function h for the different state vectors of the X at time t, and store the results in the first Ny columns of X. X is an ensemble matrix that contains the observation vectors in the first Ny lines, and the state vectors in the lines Ny+1 to Ny+Nx. The code can run in serial or with multithreading.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.observe-Tuple{StateSpace,Array{Float64,1},Float64}","page":"Functions and types","title":"TransportBasedInference.observe","text":"observe(F::StateSpace, x::Array{Float64,1}, t::Float64) -> Any\n\n\nApply the observation operator of the StateSpace F to the ensemble matrix X at time t.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.qraddrow-Union{Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,2}}} where T","page":"Functions and types","title":"TransportBasedInference.qraddrow","text":"Add a row and update a Q-less QR factorization.\n\nqraddrow!(R, a) returns the triangular part of a QR factorization of [A; a], where A = QR for some Q.  The argument 'a' should be a row vector.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.qrdelcol-Union{Tuple{T}, Tuple{AbstractArray{T,2},Int64}} where T","page":"Functions and types","title":"TransportBasedInference.qrdelcol","text":"Delete the k-th column and update a Q-less QR factorization.\n\nR = qrdelcol(R,k) deletes the k-th column of the upper-triangular R and restores it to upper-triangular form.  On input, R is an n x n upper-triangular matrix.  On output, R is an n-1 x n-1 upper triangle.\n\n18 Jun 2007: First version of QRdelcol.m.\n             Michael Friedlander (mpf@cs.ubc.ca) and\n             Michael Saunders (saunders@stanford.edu)\n             To allow for R being sparse,\n             we eliminate the k-th row of the usual\n             Hessenberg matrix rather than its subdiagonals,\n             as in Reid's Bartel-Golub LU update and also\n             the Forrest-Tomlin update.\n             (But Matlab will still be pretty inefficient.)\n18 Jun 2007: R is now the exact size on entry and exit.\n30 Dec 2015: Translate to Julia.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.rdnortho-Tuple{Int64}","page":"Functions and types","title":"TransportBasedInference.rdnortho","text":"rdnortho(N::Int64) -> Array{Float64,2}\n\n\nA routine to generate mean-preserving random rotations.\n\nReferences:\n\nNerger, L., Janjić, T., Schröter, J., & Hiller, W. (2012). A unification of ensemble square root Kalman filters. Monthly Weather Review, 140(7), 2335-2345. Tödter, J., & Ahrens, B. (2015). A second-order exact ensemble square root filter for nonlinear data assimilation. Monthly Weather Review, 143(4), 1347-1367.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.rmse-Tuple{Array{Float64,1},Array{Float64,2}}","page":"Functions and types","title":"TransportBasedInference.rmse","text":"rmse(X)\n\nCompute the root-mean square error of the ensemble matrix X    \n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.sample_banana-Tuple{Any}","page":"Functions and types","title":"TransportBasedInference.sample_banana","text":"sample_banana(N; μ = 0.0, σ = 2.0, bananicity = 0.2)\n\nGenerate N samples [x₁; x₂] of the Banana distribution defined as:     x₁ ∼ N(μ, σ²),     ϵ  ∼ N(0, 1),     x₂ ∼ bananicity × (x₁ - σ²) + ϵ.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.seqassim-Tuple{StateSpace,SyntheticData,Int64,InflationType,SeqFilter,Any,Any,Any,Float64,Localization}","page":"Functions and types","title":"TransportBasedInference.seqassim","text":"\tseqassim(F::StateSpace, data::SyntheticData, J::Int64, ϵx::InflationType, algo::SeqFilter, X, Ny, Nx, t0::Float64, Loc::Localization)\n\nGeneric API for localized sequential data assimilation for any sequential filter of parent type SeqFilter with localization scheme Loc.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.seqassim-Tuple{StateSpace,SyntheticData,Int64,InflationType,SeqFilter,Any,Any,Any,Float64}","page":"Functions and types","title":"TransportBasedInference.seqassim","text":"\tseqassim(F::StateSpace, data::SyntheticData, J::Int64, ϵx::InflationType, algo::SeqFilter, X, Ny, Nx, t0::Float64)\n\nGeneric API for sequential data assimilation for any sequential filter of parent type SeqFilter.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.spread-Tuple{Array{Float64,2}}","page":"Functions and types","title":"TransportBasedInference.spread","text":"spread(X)\n\nCompute the spread of the ensemble matrix X\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.state-Tuple{Any,Any,Any}","page":"Functions and types","title":"TransportBasedInference.state","text":"state(X, Ny, Nx)\n\nA function to extract the lines Ny+1 to Ny+Nx of the ensemble matrix X, typically storing the state.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.vander!-Tuple{Any,CstLinPhyHermite,Int64,Int64,Any}","page":"Functions and types","title":"TransportBasedInference.vander!","text":"vander!(dV, B::CstLinPhyHermite, maxi::Int64, k::Int64, x)\n\nCompute the Vandermonde matrix for the vector x\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.vander!-Tuple{Any,CstLinProHermite,Int64,Int64,Any}","page":"Functions and types","title":"TransportBasedInference.vander!","text":"vander!(dV, B::CstLinProHermite, maxi::Int64, k::Int64, x)\n\nCompute the Vandermonde matrix for the vector x\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.vander!-Tuple{Any,CstPhyHermite,Int64,Int64,Any}","page":"Functions and types","title":"TransportBasedInference.vander!","text":"vander!(dV, B::CstPhyHermite, maxi::Int64, k::Int64, x)\n\nCompute the Vandermonde matrix for the vector x\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.viewmeas-Tuple{Any,Any,Any}","page":"Functions and types","title":"TransportBasedInference.viewmeas","text":"viewmeas(X, Ny, Nx)\n\nCreate a view of the first Ny lines of the ensemble matrix X, typically storing the observations.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.viewstate-Tuple{Any,Any,Any}","page":"Functions and types","title":"TransportBasedInference.viewstate","text":"viewstate(X, Ny, Nx)\n\nCreate a view of the lines Ny+1 to Ny+Nx of the ensemble matrix X, typically storing the state.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#Types","page":"Functions and types","title":"Types","text":"","category":"section"},{"location":"manual/functions/","page":"Functions and types","title":"Functions and types","text":"Modules = [TransportBasedInference]\nOrder   = [:type]","category":"page"},{"location":"manual/functions/#TransportBasedInference.AdditiveInflation-Tuple{Any,Int64,Int64}","page":"Functions and types","title":"TransportBasedInference.AdditiveInflation","text":"    (A::AdditiveInflation)(X, start::Int64, final::Int64)\n\nApply the additive inflation A to the lines start to final of an ensemble matrix X, i.e. xⁱ -> xⁱ + ϵⁱ with ϵⁱ ∼ A.α.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.AdditiveInflation-Tuple{Any}","page":"Functions and types","title":"TransportBasedInference.AdditiveInflation","text":"    (A::AdditiveInflation)(X)\n\nApply the additive inflation A to an ensemble matrix X, i.e. xⁱ -> xⁱ + ϵⁱ with ϵⁱ ∼ A.α.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.AdditiveInflation-Tuple{Array{Float64,1}}","page":"Functions and types","title":"TransportBasedInference.AdditiveInflation","text":"    (A::AdditiveInflation)(x::Array{Float64,1})\n\nApply the additive inflation A to the vector x, i.e. x -> x + ϵ with ϵ ∼ A.α.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.Hermite","page":"Functions and types","title":"TransportBasedInference.Hermite","text":"Hermite\n\nAn abstract type for 1D Hermite polynomials and functions\n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#TransportBasedInference.IdFilter","page":"Functions and types","title":"TransportBasedInference.IdFilter","text":"IdFilter <: SeqFilter\n\nAn immutable structure for the identity filter.\n\nFields\n\nΔtdyn::Float64: time-step of the dynamical model\nΔtobs::Float64: time-step between two observations\n\nConstructors\n\nIdFilter(Δtdyn, Δtobs): set up an identity filter\n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#TransportBasedInference.IdFilter-Tuple{Any,Any,Any}","page":"Functions and types","title":"TransportBasedInference.IdFilter","text":"(filter::IdFilter)(X, ystar, t)\n\nApplies the identity transformation to the ensemble `X`.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.IdentityInflation","page":"Functions and types","title":"TransportBasedInference.IdentityInflation","text":"IdentityInflation <: InflationType\n\nAn type to store identity inflation :\n\nDefine additive inflation: x <- x\n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#TransportBasedInference.IdentityInflation-Tuple{Any}","page":"Functions and types","title":"TransportBasedInference.IdentityInflation","text":"    (A::IdentityInflation)(X)\n\nApply an IdentityInflation A on an ensemble matrix X, i.e. xⁱ -> xⁱ\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.InflationType","page":"Functions and types","title":"TransportBasedInference.InflationType","text":"InflationType\n\n\n\nAn abstract type for Inflation.\n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#TransportBasedInference.InvPreconditioner","page":"Functions and types","title":"TransportBasedInference.InvPreconditioner","text":"InvPreconditioner\n\nAn immutable structure to hold the inverse of the preconditioner. For instance, this structure can be used to hold the estimate of the inverse of the Hessian in the BFGS algorithm.\n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#TransportBasedInference.LinearTransform","page":"Functions and types","title":"TransportBasedInference.LinearTransform","text":"LinearTransform\n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#TransportBasedInference.Model","page":"Functions and types","title":"TransportBasedInference.Model","text":"    Model\n\nA structure to perform the twin-experiment\n\nFields\n\nNx : Dimension of the state variable\nNy : Dimension of the observation variable\nΔtdyn : Time-step for the dynamical model\nΔtobs : Time step between two observations of the state\nϵx : Process noise\nϵy : Observation noise\nπ0 : Multivariate distribution for the initial condition\nTburn : Number of steps to burn from the end of the spin up to compute the metrics\nTstep : Number of steps for which the filter to be tested is applied\nTspinup : Number of steps of spin-up phase,  i.e. number of steps to generate the initial ensemble for the filtering algorithms\nF : State-Space Model\n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#TransportBasedInference.MultiAddInflation","page":"Functions and types","title":"TransportBasedInference.MultiAddInflation","text":"MultiAddInflation <: InflationType\n\nAn type to store multiplico-additive inflation :\n\nDefine multiplico-additive inflation: xⁱ -> x̄ + β*(xⁱ - x̄)  + ϵⁱ with ϵⁱ ∼ α and β a scalar\n\nFields:\n\nNx : dimension of the vector\n'β' : Multiplicative inflation factor\n'α' : Distribution of the additive inflation\n\nConstructors:\n\nMultiAddInflation(Nx::Int64, β::Real, α::ContinuousMultivariateDistribution)\nMultiAddInflation(Nx::Int64, β::Float64, m::Array{Float64,1}, Σ)\nMultiAddInflation(Nx::Int64, β::Float64, m::Array{Float64,1}, σ::Array{Float64,1})\nMultiAddInflation(Nx::Int64, β::Float64, m::Array{Float64,1}, σ::Float64)\n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#TransportBasedInference.MultiAddInflation-Tuple{Any,Int64,Int64}","page":"Functions and types","title":"TransportBasedInference.MultiAddInflation","text":"    (A::MultiAddInflation)(X, start::Int64, final::Int64)\n\nApply the multiplicat inflation A to the lines start to final of an ensemble matrix X, i.e. xⁱ -> x̄ + β*(xⁱ - x̄)  + ϵⁱ with ϵⁱ ∼ A.α and β a scalar, usually ∼ 1.0.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.MultiAddInflation-Tuple{Any}","page":"Functions and types","title":"TransportBasedInference.MultiAddInflation","text":"    (A::MultiAddInflation)(X, start::Int64, final::Int64)\n\nApply the multiplico-additive inflation A to the ensemble matrix X, i.e. xⁱ -> x̄ + β*(xⁱ - x̄)  + ϵⁱ with ϵⁱ ∼ A.α and β a scalar, usually ∼ 1.0.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.MultiplicativeInflation","page":"Functions and types","title":"TransportBasedInference.MultiplicativeInflation","text":"MultiplicativeInflation <: InflationType\n\nAn type to store multiplicative inflation :\n\nxⁱ -> xⁱ + β*(xⁱ - x̄) with β a scalar\n\nFields:\n\n'β' : multiplicative inflation factor\n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#TransportBasedInference.MultiplicativeInflation-Tuple{Any,Int64,Int64}","page":"Functions and types","title":"TransportBasedInference.MultiplicativeInflation","text":"    (A::MultiplicativeInflation)(X, start::Int64, final::Int64)\n\nApply the multiplicative inflation A to the lines start to final of an ensemble matrix X, i.e. xⁱ -> x̄ + β*(xⁱ - x̄)  with β scalar, usually ∼ 1.0.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.MultiplicativeInflation-Tuple{Any}","page":"Functions and types","title":"TransportBasedInference.MultiplicativeInflation","text":"    (A::MultiplicativeInflation)(X)\n\nApply the multiplicative inflation A to an ensemble matrix X, i.e. xⁱ -> x̄ + β*(xⁱ - x̄)  with β scalar, usually ∼ 1.0.\n\n\n\n\n\n","category":"method"},{"location":"manual/functions/#TransportBasedInference.Parallel","page":"Functions and types","title":"TransportBasedInference.Parallel","text":"Parallel\n\nAn abstract type for the different kinds of parallel programming supported.\n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#TransportBasedInference.PhyHermite","page":"Functions and types","title":"TransportBasedInference.PhyHermite","text":"PhyHermite <: Hermite\n\nAn immutable structure for physicist Hermite functions defined as ψm(x) = Hm(x)*exp(-x^2/2).\n\nFields\n\nm : order of the function\nPoly : physicist Hermite polynomial of order m\nscaled : with rescaling to have unitary norm\n\nConstructors\n\nPhyHermite(m, Poly, scaled) PhyHermite(m; scaled = false)\n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#TransportBasedInference.SeqFilter","page":"Functions and types","title":"TransportBasedInference.SeqFilter","text":"SeqFilter\n\nAn abstract type for the ensemble filtering algorithms.\n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#TransportBasedInference.Serial","page":"Functions and types","title":"TransportBasedInference.Serial","text":"Serial <: Parallel\n\nA type for serial computing\n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#TransportBasedInference.StateSpace","page":"Functions and types","title":"TransportBasedInference.StateSpace","text":"struct StateSpace\n\nAn immutable structure representing the dynamical f and observation h operators. The dynamical model is provided by the right hand side of the ODE to solve. For a system of ODEs, we will prefer an in-place syntax f(du, u, p, t), where p are parameters of the model. We rely on OrdinaryDiffEq to integrate the dynamical system with the Tsitouras 5/4 Runge-Kutta method adaptive time marching. h must be a function of the form h(u, t), where u is the state vector and t is the time.\n\nFields\n\nf::Function\nPropagatation f\nh::Function\nObservation h\n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#TransportBasedInference.SyntheticData","page":"Functions and types","title":"TransportBasedInference.SyntheticData","text":"SyntheticData\n\nA structure to store the synthetic data in a twin-experiment\n\nFields\n\ntt : time history\nx0 : the initial condition\nxt : history of the state\nyt : history of the observations\n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#TransportBasedInference.Thread","page":"Functions and types","title":"TransportBasedInference.Thread","text":"Thread <: Parallel\n\nA type for multi-threaded computing\n\n\n\n\n\n","category":"type"},{"location":"manual/functions/#Index","page":"Functions and types","title":"Index","text":"","category":"section"},{"location":"manual/functions/","page":"Functions and types","title":"Functions and types","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"#AdaptiveTransportMap.jl","page":"Home","title":"AdaptiveTransportMap.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A framework for Bayesian inference with transport maps","category":"page"},{"location":"","page":"Home","title":"Home","text":"The objective of this package is to allow for easy and fast resolution of Bayesian inference problems using transport maps. The package provides tools for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"joint and conditional density estimation from limited samples of the target distribution using the adaptive transport map algorithm developed by Baptista et al. [1].\nsequential inference for state-space models using one of the following algorithms: the stochastic ensemble Kalman filter (Evensen [2]), the ensemble transform Kalman filter (Bishop et al. [3]) and a nonlinear generalization of the stochastic ensemble Kalman filter (Spantini et al. [4]).","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package has been designed to address the following question:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Given samples boldsymbolx^i sim pi For a random variable mathsfX sim pi where pi a complex distribution of interest, can we identify a transformation boldsymbolS such that the target distribution is pushed forward to a reference density eta (e.g. the standard Gaussian distribution).","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Baptista, R., Zahm, O., & Marzouk, Y. (2020). An adaptive transport framework for joint and conditional density estimation. arXiv preprint arXiv:2009.10303.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: Evensen, G., 1994. Sequential data assimilation with a nonlinear quasi‐geostrophic model using Monte Carlo methods to forecast error statistics. Journal of Geophysical Research: Oceans, 99(C5), pp.10143-10162.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3]: Bishop, C.H., Etherton, B.J. and Majumdar, S.J., 2001. Adaptive sampling with the ensemble transform Kalman filter. Part I: Theoretical aspects. Monthly weather review, 129(3), pp.420-436.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[4]: Spantini, A., Baptista, R., & Marzouk, Y. (2019). Coupling techniques for nonlinear ensemble filtering. arXiv preprint arXiv:1907.00389.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[5]: Le Provost, M., Baptista, R., Marzouk, Y., & Eldredge, J. (2021). A low-rank nonlinear ensemble filter for vortex models of aerodynamic flows. In AIAA Scitech 2021 Forum (p. 1937).","category":"page"}]
}
