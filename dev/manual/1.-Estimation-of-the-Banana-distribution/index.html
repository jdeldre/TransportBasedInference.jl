<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>- · TransportBasedInference.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">TransportBasedInference.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>-</a><ul class="internal"><li><a class="tocitem" href="#.-Estimation-of-the-Banana-distribution"><span>1. Estimation of the Banana distribution</span></a></li><li><a class="tocitem" href="#Problem-setup"><span>Problem setup</span></a></li></ul></li><li><a class="tocitem" href="../functions/">Functions and types</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>-</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>-</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/mleprovost/TransportBasedInference.jl/blob/master/docs/src/manual/1.-Estimation-of-the-Banana-distribution.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id=".-Estimation-of-the-Banana-distribution"><a class="docs-heading-anchor" href="#.-Estimation-of-the-Banana-distribution">1. Estimation of the Banana distribution</a><a id=".-Estimation-of-the-Banana-distribution-1"></a><a class="docs-heading-anchor-permalink" href="#.-Estimation-of-the-Banana-distribution" title="Permalink"></a></h2><p>In this notebook, we will show how we can estimate a density <span>$\pi$</span> given a limited number of samples <span>$\boldsymbol{x}^i \sim \pi \in \mathbb{R}^{N_x}$</span>. We will rely on the adaptive estimation framework developed in Baptista et al. [1].</p><p>References:</p><p>[1] Baptista, R., Zahm, O., &amp; Marzouk, Y. (2020). An adaptive transport framework for joint and conditional density estimation. arXiv preprint arXiv:2009.10303.</p><p>[2] Marzouk, Y., Moselhy, T., Parno, M., &amp; Spantini, A. (2016). Sampling via measure transport: An introduction. Handbook of uncertainty quantification, 1-41.</p><pre><code class="language-">using LinearAlgebra
using TransportBasedInference
using Statistics
using Distributions
nothing #hide</code></pre><p>Load some packages to make nice figures</p><h2 id="Problem-setup"><a class="docs-heading-anchor" href="#Problem-setup">Problem setup</a><a id="Problem-setup-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-setup" title="Permalink"></a></h2><p>We start by generating <span>$N_e$</span> samples from a banana distribution using the function <code>sample_banana</code>.</p><pre><code class="language-julia">Ne = 500 # Number of samples
Nx = 2 # Dimension of the state

# Define the parameters of the banana distribution
μ = 0.0
σ = 2.0
bananicity = 0.3

# Generate the samples
X = sample_banana(Ne, μ = μ, σ = σ, bananicity = bananicity)</code></pre><p><code>X</code> is an ensemble matrix whose columns are the different ensemble members, i.e. <span>$\boldsymbol{X} = \left[ \boldsymbol{x}^1, \ldots, \boldsymbol{x}^{N_e} \right]  \in \mathbb{R}^{N_x \times N_e}$</span>.</p><pre><code class="language-">Nlog = 100
logbanana = zeros(Nlog, Nlog)

xrange = range(-6.0; stop = 6.0, length = Nlog)
yrange = range(-4.0; stop = 6.0, length = Nlog)

for (i,x) in enumerate(xrange)
    for (j,y) in enumerate(yrange)
        logbanana[i,j] = log_pdf_banana([x;y]; μ = μ, σ = σ, bananicity = bananicity)
    end
end


contour(xrange, yrange, exp.(logbanana)&#39;, ratio = 1,
         title = &quot;True density&quot;,
         colorbar = false, grid = false,
         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),
         xlim = (xrange[1], xrange[end]), ylim = (-Inf, Inf), linewidth = 3)</code></pre><p>We define an object <code>S</code> of  type<code>HermiteMap</code>to hold the Knothe-Rosenblatt rearrangement that pushes forward <span>$\pi$</span> to the reference density, i.e. the standard Gaussian distribution <span>$\rho$</span>. The default constructor for an <code>HermiteMap</code> requires, where <span>$m$</span> is the maximal order of the Hermite polynomials considered in the expansion, <span>$N_x$</span> the dimension of the state, <span>$L$</span> a linear transformation that rescale the samples to get zero mean and unitary standard deviation component-wise, and <span>$C$</span> an array of <span>$N_x$</span> <code>MapComponent</code>.</p><pre><code class="language-julia">m = 30
S = HermiteMap(m, X; diag = true, b = &quot;CstLinProHermite&quot;)</code></pre><pre class="documenter-example-output">Hermite map of dimension 2:
Hermite map component of dimension 1 with Nψ = 1 active features
Hermite map component of dimension 2 with Nψ = 1 active features
</pre><p>The next step is to use the greedy algorithm developed by Baptista et al. (2020) to construct a sparse expansion of the different components of the map <span>$S$</span>. Depending on the accuracy of the amp required. Several options are possible for the optimization:</p><ul><li><code>kfold</code> uses a k-fold cross validation procedure (the more robust choice)</li><li><code>split</code> splits the set of samples into a training and a testing</li><li>An <code>Int64</code> to determine the maximum number of features for each component <span>$s^k$</span> of the map <span>$S$</span></li><li><code>nothing</code> to simply optimize the existing coefficients in the basis expansion.</li></ul><pre><code class="language-julia">optimize(S, X, &quot;kfold&quot;; withqr = true)</code></pre><pre class="documenter-example-output">Hermite map of dimension 2:
Hermite map component of dimension 1 with Nψ = 1 active features
Hermite map component of dimension 2 with Nψ = 14 active features
</pre><p>The map <span>$S$</span> is an approximation of the pushforward of the target density <span>$\pi$</span>, to the standard Gaussian density <span>$\rho$</span>.</p><p>We can access the different components of the map <span>$S$</span> as follows:</p><pre><code class="language-julia">S[1]</code></pre><pre class="documenter-example-output">Hermite map component of dimension 1 with Nψ = 1 active features
</pre><pre><code class="language-julia">S[2]</code></pre><pre class="documenter-example-output">Hermite map component of dimension 2 with Nψ = 14 active features
</pre><p>We can access the coefficients of the expansion for each map component with <code>getcoeff</code>.</p><pre><code class="language-julia">getcoeff(S[2])</code></pre><pre class="documenter-example-output">14-element Array{Float64,1}:
  17.020159786589463
 -19.535335414624416
   7.274058696087189
 -11.90670642064921
   0.8868176605251951
   6.321927507121735
  -5.827609679391551
  -1.5961131678976377
   1.6433381319912919
  -5.873205168344148
   1.2084612723437893
  -2.452671029725279
   2.2806334644312583
  -1.373473989715906</pre><pre><code class="language-">plot(S[2].I.f)</code></pre><p><code>getidx</code> can be used to obtain the active features of the different map components. The number of columns is the number of dimensions. Each line correspond to a multi-index for the different components.</p><pre><code class="language-julia">getidx(S[2])</code></pre><pre class="documenter-example-output">14×2 Array{Int64,2}:
 1  0
 0  1
 0  2
 0  3
 2  0
 0  4
 0  5
 3  0
 4  0
 5  0
 6  0
 7  0
 0  6
 0  7</pre><p>Using <code>PlotRecipes.jl</code>, we plot the number of occurences of each variable (<em>columns</em>) in each map component (<em>rows</em>).</p><pre><code class="language-">plot(S)</code></pre><p>By setting <code>degree = true</code>, we plot maximum multi-index of the features identified for each variable (<em>columns</em>) in each map component (<em>rows</em>)</p><pre><code class="language-">plot(S; degree = true)</code></pre><p>We can now compare the log-density of the true Banana density with the approximated one. Let&#39;s create a grid and evaluate the logpdf the densities.</p><pre><code class="language-">logbanana_approx = zeros(Nlog, Nlog)
lognormal = zeros(Nlog, Nlog)

for (i,x) in enumerate(xrange)
    for (j,y) in enumerate(yrange)
        logbanana_approx[i,j] = log_pdf(S, reshape([x; y], (2,1)))[1]
        lognormal[i,j] = logpdf(MvNormal(zeros(2), 1.0), [x;y])
    end
end

plt = plot(layout = grid(1, 2), colorbar = false, grid = false)
contour!(plt[1,1], xrange, yrange, exp.(logbanana)&#39;, ratio = 1,
         title = &quot;True density&quot;,
         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),
         xlim = (xrange[1], xrange[end]), ylim = (-Inf, Inf), linewidth = 3)

contour!(plt[1,2], xrange, yrange, exp.(logbanana_approx)&#39;, ratio = 1,
         title = &quot;ATM approximate&quot;,
         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),
         xlim = (xrange[1], xrange[end]), ylim = (-Inf, Inf), linewidth = 3)</code></pre><p>We can overlap the estimated density with the samples</p><pre><code class="language-">contour(xrange, yrange, exp.(logbanana_approx)&#39;, ratio = 1, colorbar = false,
         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),
         xlim = (-Inf, Inf), ylim = (-Inf, Inf), linewidth = 3)
scatter!(X[1,:], X[2,:]; legend = false, color = :purple3, ratio = 1, markersize = 6)</code></pre><p>By definition, the map <span>$S$</span> pushes forward the samples <span>$\boldsymbol{x}^i$</span> to the standard normal distribution <span>$\rho$</span> of <span>$\mathbb{R}^2$</span>, denoted <span>$\boldsymbol{S}_{\sharp} \pi = \rho$</span>,  i.e. <span>$\boldsymbol{x}^i \sim \pi \Rightarrow{} \boldsymbol{S}(\boldsymbol{x}^i) \sim \rho$</span>.</p><pre><code class="language-">SpushX = evaluate(S, X)

contour(xrange, yrange, exp.(lognormal)&#39;, ratio = 1, colorbar = false,
         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),
         xlim = (-Inf, Inf), ylim = (-Inf, Inf), linewidth = 3)
scatter!(SpushX[1,:], SpushX[2,:]; legend = false, color = :purple3, ratio = 1, markersize = 6)</code></pre><p>We can compute the statistics of the pushed samples</p><pre><code class="language-julia">mean(SpushX; dims = 2)[:,1] # close to zero</code></pre><pre class="documenter-example-output">2-element Array{Float64,1}:
  0.006112154872178882
 -0.0002738276379476932</pre><pre><code class="language-julia">cov(SpushX; dims = 2) # close to the identity matrix</code></pre><pre class="documenter-example-output">2×2 Array{Float64,2}:
 0.999949    0.00145135
 0.00145135  0.993209</pre><p>We can use the map <span>$\boldsymbol{S}$</span> to generate new samples from the target density <span>$\pi$</span>. The map <span>$\boldsymbol{S}$</span> pulls back  samples <span>$\boldsymbol{z}^i$</span> of the standard normal distribution <span>$\rho$</span> to the target density <span>$\pi$</span>, denoted <span>$\boldsymbol{S}^{\sharp} \rho = \pi$</span>, i.e. <span>$\boldsymbol{z}^i \sim \rho \Rightarrow{} \boldsymbol{S}^{-1}(\boldsymbol{z}^i) \sim \pi$</span>.</p><pre><code class="language-julia">Znew = randn(Nx, Ne)
Xnew = zeros(Nx, Ne)</code></pre><pre class="documenter-example-output">2×500 Array{Float64,2}:
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  …  0.0  0.0  0.0  0.0  0.0  0.0  0.0
 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0     0.0  0.0  0.0  0.0  0.0  0.0  0.0</pre><p>We use the in-place routine <code>inverse</code> to solve the triangular system <span>$\boldsymbol{S}(\boldsymbol{x}^i) = \boldsymbol{z}^i$</span> for <span>$\boldsymbol{x}^i \in \mathbb{R}^{N_x}$</span> for the different samples. From the lower triangular structure of <span>$\boldsymbol{S}$</span>, this inversion reduces to a sequence of one dimensional root finding problems Marzouk et al. [2].</p><pre><code class="language-julia">inverse!(Xnew, copy(Znew), S)
evaluate(S, Xnew)-Znew</code></pre><pre class="documenter-example-output">2×500 Array{Float64,2}:
 -9.76541e-12  -8.73087e-11  -5.32029e-11  …  -2.78388e-14  2.48179e-10
  2.22045e-15   6.66134e-16   1.33227e-15     -2.22045e-16  8.88178e-16</pre><pre><code class="language-">plt = plot(layout = grid(1, 2))

contour!(plt[1,1], xrange, yrange, exp.(lognormal)&#39;, ratio = 1, colorbar = false,
         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),
         xlim = (xrange[1], xrange[end]), ylim = (yrange[1], yrange[end]), linewidth = 3)
scatter!(plt[1,1], Znew[1,:], Znew[2,:]; legend = false, color = :purple3, ratio = 1, markersize = 6,
         title = L&quot;z^i \sim \rho&quot;)

contour!(plt[1,2], xrange, yrange, exp.(logbanana)&#39;, ratio = 1, colorbar = false,
         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),
         xlim = (xrange[1], xrange[end]), ylim = (yrange[1], yrange[end]), linewidth = 3)
scatter!(plt[1,2], Xnew[1,:], Xnew[2,:]; legend = false, color = :purple3, ratio = 1, markersize = 6,
            title = L&quot;S^{-1}(z^i) \sim S^{\sharp}\rho&quot;)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« Home</a><a class="docs-footer-nextpage" href="../functions/">Functions and types »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 12 July 2021 19:28">Monday 12 July 2021</span>. Using Julia version 1.5.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
