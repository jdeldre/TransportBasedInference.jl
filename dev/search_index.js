var documenterSearchIndex = {"docs":
[{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/#.-Linear-ensemble-filtering-for-the-Lorenz-63-problem","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"","category":"section"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"In this notebook, we are interested in the filtering problem, the estimation of the conditional distribution of the state variable given the knowledge of all the observations up to that time. In practice, we use a particle approximation of the filtering density, which is recursively updated in a two-step procedure: a forecast step and an analysis step.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"In the forecast step, the filtering ensemble is propagated through the dynamical model to generate samples from the forecast ensemble.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"The analysis step updates the forecast ensemble by assimilating the newly available observation from the true system. The resulting ensemble forms a particle approximation of the filtering density at the next step.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"The analysis step does not involve time propagation and can be treated as a static Bayesian problem, see notebook 2. Different algorithms have been developed to perform the analysis of the measurement. In particular, the ensemble Kalman filter (EnKF) developed by Evensen [1] uses a linear transformation in the analysis step. This linear transformation is estimated under Gaussian assumptions. In this notebook, we apply the EnKF to the Lorenz-63 problem.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"References","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"[1]: Evensen, G., 1994. Sequential data assimilation with a nonlinear quasi‐geostrophic model using Monte Carlo methods to forecast error statistics. Journal of Geophysical Research: Oceans, 99(C5), pp.10143-10162.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"[2]: Asch, M., Bocquet, M. and Nodet, M., 2016. Data assimilation: methods, algorithms, and applications. Society for Industrial and Applied Mathematics.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"[3]: Bishop, C.H., Etherton, B.J. and Majumdar, S.J., 2001. Adaptive sampling with the ensemble transform Kalman filter. Part I: Theoretical aspects. Monthly weather review, 129(3), pp.420-436.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"[4]: Lorenz, E.N., 1963. Deterministic nonperiodic flow. Journal of atmospheric sciences, 20(2), pp.130-141.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"[5]: Spantini, A., Baptista, R. and Marzouk, Y., 2019. Coupling techniques for nonlinear ensemble filtering. arXiv preprint arXiv:1907.00389.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"To perform sequential inference in TransportBasedInference, we need to provide the following:","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Specify the problem: Define the state-space model: initial condition, dynamical and observation models (including process and observation noise)\nSpecify the inflation parameters: Determine the covariance inflation to properly balance the dynamical system and the observations from the truth system\nSpecify the filter: Choose the ensemble filter to assimilate the observations in the state estimate\nPerform the sequential inference: Perform the sequential inference","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"using Revise\nusing LinearAlgebra\nusing TransportBasedInference\nusing Statistics\nusing Distributions","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Load some packages to make nice figures","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"using Plots\ndefault(tickfont = font(\"CMU Serif\", 9),\n        titlefont = font(\"CMU Serif\", 14),\n        guidefont = font(\"CMU Serif\", 12),\n        legendfont = font(\"CMU Serif\", 10),\n        grid = false)\npyplot()\n\nusing LaTeXStrings\nusing ColorSchemes","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"The Lorenz-63  model is a three dimensional system that models the atmospheric convection [4]. This system is a classical benchmark problem in data assimilation. The state boldsymbolx = (x_1 x_2 x_3) is governed by the following set of ordinary differential equations:","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"beginaligned\nfracmathrmd x_1mathrmd t=sigma(x_2-x_1)\nfracmathrmd x_2mathrmd t=x_1(rho-x_2)-x_2\nfracmathrmd x_3mathrmd t=x_1 x_2-beta x_3\nendaligned","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"where sigma = 10 beta = 83 rho = 28. For these values, the system is chaotic and behaves like a strange attractor. We integrate this system of ODEs with time step Delta t_dyn = 005. The state is fully observed h(boldsymbolx t) = boldsymbolx with Delta t_obs=01. The initial distribution pi_mathsfX_0 is the standard Gaussian. The process noise is Gaussian with zero mean and covariance 10^-4boldsymbolI_3. The measurement noise has a Gaussian distribution with zero mean and covariance theta^2boldsymbolI_3 where theta^2 = 40.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Simple twin-experiment","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Define the dimension of the state and observation vectors","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Nx = 3\nNy = 3","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Define the time steps Delta t_dyn Delta t_obs  of the dynamical and observation models. Observations from the truth are assimilated every Delta t_obs.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Δtdyn = 0.05\nΔtobs = 0.1","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Define the time span of interest","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"t0 = 0.0\ntf = 100.0\nTf = ceil(Int64, (tf-t0)/Δtobs)","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Define the distribution for the initial condition pi_mathsfX_0","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"π0 = MvNormal(zeros(Nx), Matrix(1.0*I, Nx, Nx))","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"We construct the state-space representation F of the system composed of the deterministic part of the dynamical and observation models.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"The dynamical model is provided by the right hand side of the ODE to solve. For a system of ODEs, we will prefer an in-place syntax f(du, u, p, t), where p are parameters of the model. We rely on OrdinaryDiffEq to integrate the dynamical system with the Tsitouras 5/4 Runge-Kutta method adaptive time marching.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"We assume that the state is fully observable, i.e. h(x t) = x.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Note: the right-hand-side of the Lorenz-63 model is implemented in TransportBasedInference.jl under the name lorenz63!. The code is reproduced for convenience.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"function lorenz63!(du,u,p,t)\n    du[1] = 10.0*(u[2]-u[1])\n    du[2] = u[1]*(28.0-u[3]) - u[2]\n    du[3] = u[1]*u[2] - (8/3)*u[3]\n    return du\nend","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"h(x, t) = x\nF = StateSpace(lorenz63!, h)","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"ϵx defines the additive process noise applied between the forecast step and the analysis step. The process noise is applied before to sample form the likelihood.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"ϵy defines the additive observation noise.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"We assume that these noises have Gaussian distribution.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"σx = 1e-1\nσy = 4.0\n\nϵx = AdditiveInflation(Nx, zeros(Nx), σx)\nϵy = AdditiveInflation(Ny, zeros(Ny), σy)","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Different types of inflation have been implemented in TransportBasedInference.jl:","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"IdentityInflation applies the identity transformation\nAdditiveInflation applies Gaussian noise to the ensemble members\nMultiplicativeInflation increases the spread of the ensemble  about the sample mea by a multiplicative factor beta.\nMultiAddInflation combine a multiplicative and an additive inflation.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"They are all subtypes of the abstract type InflationType.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"New types of inflation can easily be created and integrated in the existing tools of TransportBasedInference.jl, as long as the satisfy the following requirements:","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"MyInflationType <: InflationType\n(A::MyInflationType)(X::AbstractMatrix{Float64}) is defined","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"model = Model(Nx, Ny, Δtdyn, Δtobs, ϵx, ϵy, π0, 0, 0, 0, F);","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Set initial condition of the true system","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"x0 = rand(model.π0)","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Run dynamics and generate data","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"For the twin-experiment, we use the function generate_lorenz63 to integrate forward in time the Lorenz-63 ODE, and generate the observations that will be later assimilated into the ensemble filter. This function can easily be modified for your specific needs.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"data = generate_lorenz63(model, x0, Tf);","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"In TransportBasedInference.jl, we use the following convention to store the state and observation variables. The state and observation variables of the different ensemble members are stored in a common matrix X. The different columns store the different samples. The first entries of a column contains the observation variables, while the latter contains the state variables. This convention might seem confusing at first, but it is very convenient for conditional density estimation, see notebook 2 or 5 for instance.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Different ensemble filters have been implemented in TransportBasedInference.jl:","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"IdFilter: a trivial identity filter\nStochEnKF: the stochastic version of the ensemble Kalman filter (sEnKF), Evensen [1].\nETKF: the ensemble transform Kalman filter (ETKF) Bishop et al. [3]. This filter exactly verifies the propagation equation for the covariance matrix of the Kalman filter, and avoid to sample the observation noise. This filter belongs to the class of deterministic ensemble Kalman filters.\nStochMapFilter: the stochastic map filter (SMF) developed by Spantini et al. [5]. This filter is a nonlinear generalization of the sEnKF based on measure transport. This filter is presented in the notebooks 6 & 7.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"New ensemble filter can easily be created and integrated in the existing tools of TransportBasedInference.jl, as long as the satisfy the following requirements:","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"MyFilterType <: SeqFilter\n(A::MyFilterType)(X::AbstractMatrix{Float64}, ystar, t) is defined, where ystar is the observation to assimilate in the forecast ensemble X.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Define a stochastic ensemble Kalman filter","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"senkf = StochEnKF(model.ϵy, model.Δtdyn, model.Δtobs)","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Define an ensemble transform Kalman filter","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"etkf = ETKF(model.ϵy, model.Δtdyn, model.Δtobs, 20*model.Δtobs)","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Initialize the ensemble matrix X in mathbbR^(N_y + N_x) times N_e.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Ne = 100 #ensemble size\nX = zeros(model.Ny + model.Nx, Ne)\n\n# Generate the initial conditions for the state.\nviewstate(X, model.Ny, model.Nx) .= rand(model.π0, Ne)","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Apply the sequential filter over the time window","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"The function seqassim provides a friendly API to experiment with the different ensemble filters, the tuning of the different inflation parameters...","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Xsenkf = seqassim(F, data, Tf, model.ϵx, senkf, deepcopy(X), model.Ny, model.Nx, t0)\nnothing","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"Xetkf = seqassim(F, data, Tf, model.ϵx, etkf, deepcopy(X), model.Ny, model.Nx, t0)\nnothing","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"mean_hist stacked together the mean of the ensemble matrices over the assimilation window.","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"mean_hist(Xsenkf)","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"# Plot the first component of the state over time\nnb = 1\nne = size(Xsenkf,1)-1\nΔ = 1\nplt = plot(xlim = (-Inf, Inf), ylim = (-Inf, Inf), xlabel = L\"t\", ylabel = L\"x_1\")\nplot!(plt, data.tt[nb:Δ:ne], data.xt[1,nb:Δ:ne], linewidth =  3, color = :teal, label = \"True\")\nplot!(plt, data.tt[nb:Δ:ne], mean_hist(Xsenkf)[1,1+nb:Δ:1+ne], linewidth = 3, grid = false,\n     color = :orangered2, linestyle = :dash, label = \"sEnKF\")\nscatter!(plt, data.tt[nb:Δ:ne], data.yt[1,nb:Δ:ne], linewidth = 3, color = :grey, markersize = 5, alpha = 0.5, label = \"Observation\")\nplt","category":"page"},{"location":"manual/4.-Linear-ensemble-filtering-Lorenz-63/","page":"4. Linear ensemble filtering for the Lorenz-63 problem","title":"4. Linear ensemble filtering for the Lorenz-63 problem","text":"# Plot the different component of the state over time\nnb = 1\nne = size(Xsenkf,1)-1\nΔ = 1\nplt = plot(layout = grid(3,1), xlim = (-Inf, Inf), ylim = (-Inf, Inf), xlabel = L\"t\",\n           size = (900, 1000))\n\nfor i =1:3\n    plot!(plt[i,1], data.tt[nb:Δ:ne], data.xt[i,nb:Δ:ne], linewidth =  2, color = :teal,\n          ylabel = latexstring(\"x_\"*string(i)), legend = (i == 1), label = \"True\")\n    plot!(plt[i,1], data.tt[nb:Δ:ne], mean_hist(Xsenkf)[i,1+nb:Δ:1+ne], linewidth = 2, grid = false,\n          color = :orangered2, linestyle = :dash, label = \"sEnKF\")\n    scatter!(plt[i,1], data.tt[nb:Δ:ne], data.yt[i,nb:Δ:ne], linewidth = 3, color = :grey,\n          markersize = 5, alpha = 0.5, label  = \"Observation\")\nend\n\nplt","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/#.-Structure-discovery-for-the-Lorenz-96-problem","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"","category":"section"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"In this notebook, we will show how we can estimate the conditional independence structure of a random variable mathsfX in mathbbR^N_x with density pi based on i.i.d. samples boldsymbolx^i  i = 1 ldots N_e from pi.","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"using Revise\nusing LinearAlgebra\nusing TransportBasedInference\nusing Statistics\nusing Distributions\nusing OrdinaryDiffEq\nusing ProgressMeter","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"Load some packages to make nice figures","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"using Plots\ndefault(tickfont = font(\"CMU Serif\", 9),\n        titlefont = font(\"CMU Serif\", 14),\n        guidefont = font(\"CMU Serif\", 12),\n        legendfont = font(\"CMU Serif\", 10),\n        grid = false)\n\nusing LaTeXStrings\nusing ColorSchemes","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"The Lorenz-96 model [1] is a famous problem used in data assimilation and weather prediction. It was derived from first principles as a one-dimensional model for the response of the mid-latitude atmosphere to forcing input. For certain forcing input, it can exhibit a chaotic behavior: sensitivity to initial conditions, strong mixing. In this notebook, we consider the fifteen-dimensional version of the Lorenz-96 model.  The state boldsymbolx = (x_1 ldots x_15) at time t is governed by the following set of ordinary differential equations:","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"fracmathrmdx_imathrmdt = (x_i+1 - x_i-2) x_i-1 -x_i + F","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"where it is assumed that x_-1 = x_n  1  x_0 = x_n and x_n+1 = x_1, setting the forcing input F=80 leads to chaos.","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"We integrate the Lorenz-96 problem with our favorite ODE library: OrdinaryDiffEq.jl.","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"# Define the distribution for initial condition\nNx = 20\n# Number of runs\nNe = 500\nπx0 = MvNormal(zeros(Nx), ones(Nx))\n# Zero vector of the size of the state\nx0 = rand(πx0)\n\n# Time step\ntspan = (0.0, 500.0)\nprob = ODEProblem(TransportBasedInference.lorenz96!,x0, tspan)\nnothing","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"Create cache to store the different final solutions","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"X = zeros(Nx, Ne)\nnothing #hide","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"Solve Lorenz-96 model for the different initial conditions and store the solutions as the columns of X","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"@inbounds for i=1:Ne\n    prob = ODEProblem(TransportBasedInference.lorenz96!, rand(πx0), tspan)\n    sol = solve(prob, Tsit5(), dt = 0.01, adaptive = false, dense = false, saveat = tspan[end], save_start = false)\n    X[:,i] = deepcopy(sol.u[1])\nend\nnothing #hide","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"We can use the adaptive transport map procedure to estimate the underlying distribution for the state mathsfX.","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"m = 60\nS = HermiteMap(m, X; diag = true)\nnothing #hide","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"optimize(S, X, \"kfold\"; withqr = true, verbose = false, hessprecond = true)","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"plot(S)","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"Baptista et al. [3] showed that the conditional independence properties of a random variable mathsfX in mathbbR^n with density pi are specified by the Hessian score matrix boldsymbolOmega in mathbbR^n times n defined as:","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"Omega_ij = mathrmE_pi left partial_ipartial_j log pi(boldsymbolx)^2  right = int partial_ipartial_j log pi(boldsymbolx)^2 pi(boldsymbolx)  mathrmdboldsymbolx","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"The pullback density boldsymbolS^sharp rho can be used to approximate the true density pi, where rho denotes the standard Gaussian distribution of mathbbR^n. Thus, the score matrix is estimated by [3]: hatOmega_ij = mathrmE_pi left partial_ipartial_j log boldsymbolS^sharp rho^2  right","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"In practice, we use a sampled-based approximation of hatboldsymbolOmega using samples boldsymbolx^k  k=1ldots N_e of pi [3]:","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"hatOmega_ij approx sum_k=1^N_epartial_ipartial_j log boldsymbolS^sharprho(boldsymbolx^k )^2","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"The function hess_x_log_pdf! computes in-place the Hessian of the log pdf of the pullback density boldsymbolS^sharp rho. You can also use hess_x_log_pdf.","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"Ωhat = zeros(Nx, Nx)\ncache = zeros(1, Nx, Nx)\n@inbounds for i=1:Ne\n    hess_x_log_pdf!(cache, S, X[:,i:i])\n    Ωhat .+= copy(cache[1,:,:]).^2\nend\nrmul!(Ωhat, 1/Ne)\nnothing #hide","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"plt = plot(size = (800, 800))\n\nheatmap!(plt,log10.(Ωhat), ratio = 1, yflip = true,\n        colorbar = true, color = :plasma, clim = (1.5, Inf), colorbar_title = L\"\\log_{10}(\\hat{\\Omega})\",\n        xlim = (-Inf, Inf), ylim = (-Inf, Inf),\n        xlabel = \"Index\", ylabel = \"Index\", background_color_inside = palette(:plasma)[1],\n        yticks = (reverse(collect(0:10:Nx))))\nplt","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"References:","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"[1]: Lorenz, E.N., 1996, September. Predictability: A problem partly solved. In Proc. Seminar on predictability (Vol. 1, No. 1).","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"[2]: Baptista, R., Zahm, O., & Marzouk, Y. (2020). An adaptive transport framework for joint and conditional density estimation. arXiv preprint arXiv:2009.10303.","category":"page"},{"location":"manual/3.-Structure-discovery-of-the-Lorenz-96/","page":"3. Structure discovery for the Lorenz-96 problem","title":"3. Structure discovery for the Lorenz-96 problem","text":"[3]: Baptista, R., Marzouk, Y., Morrison, R.E. and Zahm, O., 2021. Learning non-Gaussian graphical models via Hessian scores and triangular transport. arXiv preprint arXiv:2101.03093.","category":"page"},{"location":"contribute/#Contribute-to-TransportBasedInference.jl","page":"Contribute to TransportBasedInference.jl","title":"Contribute to TransportBasedInference.jl","text":"","category":"section"},{"location":"contribute/","page":"Contribute to TransportBasedInference.jl","title":"Contribute to TransportBasedInference.jl","text":"We welcome contributions to TransportBasedInference.jl. The modularity of the package eases the integration of new parametrizations of transport maps, new ensemble filtering algorithms, new ensemble inflation scheme... To contribute a new feature, please submit a pull request.","category":"page"},{"location":"contribute/","page":"Contribute to TransportBasedInference.jl","title":"Contribute to TransportBasedInference.jl","text":"New types of inflation can easily be created and integrated in TransportBasedInference, as long as they satisfy the following requirements:","category":"page"},{"location":"contribute/","page":"Contribute to TransportBasedInference.jl","title":"Contribute to TransportBasedInference.jl","text":"MyInflationType <: InflationType\n(A::MyInflationType)(X::AbstractMatrix{Float64}) is defined","category":"page"},{"location":"contribute/","page":"Contribute to TransportBasedInference.jl","title":"Contribute to TransportBasedInference.jl","text":"Similarly, new ensemble filter only need to satisfy the following requirements:","category":"page"},{"location":"contribute/","page":"Contribute to TransportBasedInference.jl","title":"Contribute to TransportBasedInference.jl","text":"MyFilterType <: SeqFilter\n(A::MyFilterType)(X::AbstractMatrix{Float64}, ystar, t) is defined, where ystar is the observation to assimilate in the forecast ensemble X at time t.","category":"page"},{"location":"contribute/#Reporting-issues-or-problems","page":"Contribute to TransportBasedInference.jl","title":"Reporting issues or problems","text":"","category":"section"},{"location":"contribute/","page":"Contribute to TransportBasedInference.jl","title":"Contribute to TransportBasedInference.jl","text":"If you find a bug in the code, please open an issue with a minimal working example.","category":"page"},{"location":"contribute/#Seek-support","page":"Contribute to TransportBasedInference.jl","title":"Seek support","text":"","category":"section"},{"location":"contribute/","page":"Contribute to TransportBasedInference.jl","title":"Contribute to TransportBasedInference.jl","text":"To reach support with TransportBasedInference.jl, open a post on Julia discourse.","category":"page"},{"location":"apidoc/#Functions","page":"Functions","title":"Functions","text":"","category":"section"},{"location":"apidoc/","page":"Functions","title":"Functions","text":"Modules = [TransportBasedInference]\nOrder   = [:function]","category":"page"},{"location":"apidoc/#Base.size-Tuple{MultiAddInflation}","page":"Functions","title":"Base.size","text":"size(A::MultiAddInflation)\n\nReturn the dimension of the additive inflation of A.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},ExpandedFunction}","page":"Functions","title":"RecipesBase.apply_recipe","text":"    heatmap(M::HermiteMap; start::Int64=1, color, degree)\n\nPlot recipe for an ExpandedFunction.  We can either plot the number of occurences of each variable (columns) in each map component (rows) if degree = false (default behavior), or the maximum multi-index of the features identified for each variable (columns) in each map component (rows) if degree = true.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#RecipesBase.apply_recipe-Tuple{AbstractDict{Symbol,Any},HermiteMap}","page":"Functions","title":"RecipesBase.apply_recipe","text":"    heatmap(M::HermiteMap; start::Int64=1, color, degree)\n\nPlot recipe for an HermiteMap. We can either plot the number of occurences of each variable (columns) in each map component (rows) if degree = false (default behavior), or the maximum multi-index of the features identified for each variable (columns) in each map component (rows) if degree = true.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.DPhyPolyHermite-Tuple{Int64}","page":"Functions","title":"TransportBasedInference.DPhyPolyHermite","text":"\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.Diff-Tuple{Any,Any}","page":"Functions","title":"TransportBasedInference.Diff","text":"Diff(f,k)\n\nBy recurrence, create the k-th derivative of the scalar function f, based on ForwardDiff.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.Diff-Tuple{Any}","page":"Functions","title":"TransportBasedInference.Diff","text":"Diff(f)\n\nCreate the derivative of the scalar function f, based on ForwardDiff.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.allequal-Tuple{Any,Any}","page":"Functions","title":"TransportBasedInference.allequal","text":"allequal(x, r)\n\nA function to verify that all the entries of the vector x are equal to r\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.clenshaw_curtis-Tuple{Int64}","page":"Functions","title":"TransportBasedInference.clenshaw_curtis","text":"clenshaw_curtis(N)\n\nCompute the nodes x and weights w for integrating a continuous functions from [-1,1] using the Clenshaw-Curtis integration rule with order N.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.csne-Union{Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,2},Array{T,1}}} where T","page":"Functions","title":"TransportBasedInference.csne","text":"Solve the corrected semi-normal equations R'Rx=A'b.\n\nx, r = csne(R, A, b) solves the least-squares problem\n\nminimize  ||r||_2,  where  r := b - A*x\n\nusing the corrected semi-normal equation approach described by Bjork (1987). Assumes that R is upper triangular.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.degree-Tuple{PhyHermite}","page":"Functions","title":"TransportBasedInference.degree","text":"    degree(P)\n\nReturn the degree of the polynomial P\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.elementproductmatmul!-Tuple{Array{Float64,1},Array{Float64,2},Array{Float64,2},Array{Float64,1}}","page":"Functions","title":"TransportBasedInference.elementproductmatmul!","text":"elementproductmatmul!(d, A, B, c)\n\nCompute in-place the product (A ∘ B)*c, where ∘ denotes the element-wise  product of two matrices.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.exactn-Tuple{Any}","page":"Functions","title":"TransportBasedInference.exactn","text":"    exactn(N)\n\nA function to create a 1D sample with exactly mean 0 and covariance 1 (The samples are no longer i.i.d but this can be usueful when the initialization of the problem is challenging.)\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.fact2-Tuple{Int64}","page":"Functions","title":"TransportBasedInference.fact2","text":"fact2(n)\n\nCompute the double factorial of n, i.e. the product of the odd (if n is odd) or even (if n is even) numbers up to n.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.gradlog_pdf-Tuple{Any}","page":"Functions","title":"TransportBasedInference.gradlog_pdf","text":"gradlog_pdf(x)\n\nCompute the gradient of the log of the density of the univariate standard Gaussian distribution (zero mean and unitary standard deviation).\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.greedyfit-Tuple{Int64,Int64,Any,Any,Int64}","page":"Functions","title":"TransportBasedInference.greedyfit","text":"greedyfit(m::Int64, Nx::Int64, X, Xvalid, maxterms::Int64; withconstant, withqr, maxpatience, verbose, hessprecond) -> Tuple{HermiteMapComponent,Tuple{Array{Float64,1},Array{Float64,1}}}\n\n\nAn adaptive routine to estimate a sparse approximation of an HermiteMapComponent based on  the pair of ensemble matrices X (training set) and Xvalid (validation set).\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.greedyfit-Tuple{Int64,Int64,Any,Int64}","page":"Functions","title":"TransportBasedInference.greedyfit","text":"greedyfit(m::Int64, Nx::Int64, X, maxterms::Int64; withconstant, withqr, maxpatience, verbose, hessprecond) -> Tuple{HermiteMapComponent,Array{Float64,1}}\n\n\nAn adaptive routine to estimate a sparse approximation of an HermiteMapComponent based on  the ensemble matrix X.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.greedyfit-Tuple{Int64,Int64,Int64,AbstractArray{Float64,2},AbstractArray{Float64,2},Int64,Float64,Float64,Float64}","page":"Functions","title":"TransportBasedInference.greedyfit","text":"greedyfit(Nx::Int64, poff::Int64, pdiag::Int64, X::AbstractArray{Float64,2}, Xvalid::AbstractArray{Float64,2}, maxfamiliesoff::Int64, λ::Float64, δ::Float64, γ::Float64; maxpatience, verbose) -> Tuple{SparseRadialMapComponent,Tuple{Array{Float64,1},Array{Float64,1}}}\n\n\nAn adaptive routine to estimate a sparse approximation of an SparseRadialMapComponent based on  the pair of ensemble matrices X (training set) and Xvalid (validation set).\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.greedyfit-Tuple{Int64,Int64,Int64,AbstractArray{Float64,2},Int64,Float64,Float64,Float64}","page":"Functions","title":"TransportBasedInference.greedyfit","text":"greedyfit(Nx::Int64, poff::Int64, pdiag::Int64, X::AbstractArray{Float64,2}, maxfamiliesoff::Int64, λ::Float64, δ::Float64, γ::Float64; maxpatience, verbose) -> Tuple{SparseRadialMapComponent,Array{Float64,1}}\n\n\nAn adaptive routine to estimate a sparse approximation of an SparseRadialMapComponent based on  the ensemble matrix X.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.hesslog_pdf-Tuple{Any}","page":"Functions","title":"TransportBasedInference.hesslog_pdf","text":"hesslog_pdf(x)\n\nCompute the hessian of the log of the density of the univariate standard Gaussian distribution (zero mean and unitary standard deviation).\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.log_pdf-Tuple{Any}","page":"Functions","title":"TransportBasedInference.log_pdf","text":"log_pdf(x)\n\nCompute the log of the density of the univariate standard Gaussian distribution (zero mean and unitary standard deviation).\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.log_pdf_banana-Tuple{AbstractArray{T,1} where T}","page":"Functions","title":"TransportBasedInference.log_pdf_banana","text":"log_pdf_banana(X; μ = 0.0, σ = 2.0, bananicity = 0.2)\n\nCompute the logarithm of the porbability density function (pdf) of the Banana distribution at X. See documentation of sample_banana for details on the Banana distribution.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.lorenz63!-NTuple{4,Any}","page":"Functions","title":"TransportBasedInference.lorenz63!","text":"lorenz63!(du,u,p,t)\n\nCompute in-place the right-hand-side of the Lorenz-63 system for a state u at time t, and store it in du. p is vector of user-defined parameters.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.lorenz96!-NTuple{4,Any}","page":"Functions","title":"TransportBasedInference.lorenz96!","text":"lorenz96!(du,u,p,t)\n\nCompute in-place the right-hand-side of the Lorenz-96 system for a state u at time t, and store it in du. p is vector of user-defined parameters.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.mean_hist-Tuple{Array{Array{Float64,2},1}}","page":"Functions","title":"TransportBasedInference.mean_hist","text":"mean_hist(hist)\n\nStack together the mean of the different ensembles.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.meas-Tuple{Any,Any,Any}","page":"Functions","title":"TransportBasedInference.meas","text":"meas(X, Ny, Nx)\n\nA function to extract the first Ny lines of the ensemble matrix X, typically storing the observations.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.member-Tuple{Any,Any}","page":"Functions","title":"TransportBasedInference.member","text":"member(X, idx)\n\nExtract the idx ensemble member of the ensemble matrix X\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.observe-Tuple{Function,Any,Float64,Int64,Int64}","page":"Functions","title":"TransportBasedInference.observe","text":"observe(h::Function, X, t::Float64, Ny::Int64, Nx::Int64; P)\n\n\nEvaluate the function h for the different state vectors of the X at time t, and store the results in the first Ny columns of X. X is an ensemble matrix that contains the observation vectors in the first Ny lines, and the state vectors in the lines Ny+1 to Ny+Nx. The code can run in serial or with multithreading.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.observe-Tuple{StateSpace,Array{Float64,1},Float64}","page":"Functions","title":"TransportBasedInference.observe","text":"observe(F::StateSpace, x::Array{Float64,1}, t::Float64) -> Any\n\n\nApply the observation operator of the StateSpace F to the ensemble matrix X at time t.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.qraddrow-Union{Tuple{T}, Tuple{AbstractArray{T,2},AbstractArray{T,2}}} where T","page":"Functions","title":"TransportBasedInference.qraddrow","text":"Add a row and update a Q-less QR factorization.\n\nqraddrow!(R, a) returns the triangular part of a QR factorization of [A; a], where A = QR for some Q.  The argument 'a' should be a row vector.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.qrdelcol-Union{Tuple{T}, Tuple{AbstractArray{T,2},Int64}} where T","page":"Functions","title":"TransportBasedInference.qrdelcol","text":"Delete the k-th column and update a Q-less QR factorization.\n\nR = qrdelcol(R,k) deletes the k-th column of the upper-triangular R and restores it to upper-triangular form.  On input, R is an n x n upper-triangular matrix.  On output, R is an n-1 x n-1 upper triangle.\n\n18 Jun 2007: First version of QRdelcol.m.\n             Michael Friedlander (mpf@cs.ubc.ca) and\n             Michael Saunders (saunders@stanford.edu)\n             To allow for R being sparse,\n             we eliminate the k-th row of the usual\n             Hessenberg matrix rather than its subdiagonals,\n             as in Reid's Bartel-Golub LU update and also\n             the Forrest-Tomlin update.\n             (But Matlab will still be pretty inefficient.)\n18 Jun 2007: R is now the exact size on entry and exit.\n30 Dec 2015: Translate to Julia.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.rdnortho-Tuple{Int64}","page":"Functions","title":"TransportBasedInference.rdnortho","text":"rdnortho(N::Int64) -> Array{Float64,2}\n\n\nA routine to generate mean-preserving random rotations.\n\nReferences:\n\nNerger, L., Janjić, T., Schröter, J., & Hiller, W. (2012). A unification of ensemble square root Kalman filters. Monthly Weather Review, 140(7), 2335-2345. Tödter, J., & Ahrens, B. (2015). A second-order exact ensemble square root filter for nonlinear data assimilation. Monthly Weather Review, 143(4), 1347-1367.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.rmse-Tuple{Array{Float64,1},Array{Float64,2}}","page":"Functions","title":"TransportBasedInference.rmse","text":"rmse(X)\n\nCompute the root-mean square error of the ensemble matrix X    \n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.sample_banana-Tuple{Any}","page":"Functions","title":"TransportBasedInference.sample_banana","text":"sample_banana(N; μ = 0.0, σ = 2.0, bananicity = 0.2)\n\nGenerate N samples [x₁; x₂] of the Banana distribution defined as:     x₁ ∼ N(μ, σ²),     ϵ  ∼ N(0, 1),     x₂ ∼ bananicity × (x₁ - σ²) + ϵ.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.seqassim-Tuple{StateSpace,SyntheticData,Int64,InflationType,SeqFilter,Any,Any,Any,Float64,Localization}","page":"Functions","title":"TransportBasedInference.seqassim","text":"\tseqassim(F::StateSpace, data::SyntheticData, J::Int64, ϵx::InflationType, algo::SeqFilter, X, Ny, Nx, t0::Float64, Loc::Localization)\n\nGeneric API for localized sequential data assimilation for any sequential filter of parent type SeqFilter with localization scheme Loc.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.seqassim-Tuple{StateSpace,SyntheticData,Int64,InflationType,SeqFilter,Any,Any,Any,Float64}","page":"Functions","title":"TransportBasedInference.seqassim","text":"\tseqassim(F::StateSpace, data::SyntheticData, J::Int64, ϵx::InflationType, algo::SeqFilter, X, Ny, Nx, t0::Float64)\n\nGeneric API for sequential data assimilation for any sequential filter of parent type SeqFilter.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.spread-Tuple{Array{Float64,2}}","page":"Functions","title":"TransportBasedInference.spread","text":"spread(X)\n\nCompute the spread of the ensemble matrix X\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.state-Tuple{Any,Any,Any}","page":"Functions","title":"TransportBasedInference.state","text":"state(X, Ny, Nx)\n\nA function to extract the lines Ny+1 to Ny+Nx of the ensemble matrix X, typically storing the state.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.vander!-Tuple{Any,CstLinPhyHermite,Int64,Int64,Any}","page":"Functions","title":"TransportBasedInference.vander!","text":"vander!(dV, B::CstLinPhyHermite, maxi::Int64, k::Int64, x)\n\nCompute the Vandermonde matrix for the vector x\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.vander!-Tuple{Any,CstLinProHermite,Int64,Int64,Any}","page":"Functions","title":"TransportBasedInference.vander!","text":"vander!(dV, B::CstLinProHermite, maxi::Int64, k::Int64, x)\n\nCompute the Vandermonde matrix for the vector x\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.vander!-Tuple{Any,CstPhyHermite,Int64,Int64,Any}","page":"Functions","title":"TransportBasedInference.vander!","text":"vander!(dV, B::CstPhyHermite, maxi::Int64, k::Int64, x)\n\nCompute the Vandermonde matrix for the vector x\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.viewmeas-Tuple{Any,Any,Any}","page":"Functions","title":"TransportBasedInference.viewmeas","text":"viewmeas(X, Ny, Nx)\n\nCreate a view of the first Ny lines of the ensemble matrix X, typically storing the observations.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.viewstate-Tuple{Any,Any,Any}","page":"Functions","title":"TransportBasedInference.viewstate","text":"viewstate(X, Ny, Nx)\n\nCreate a view of the lines Ny+1 to Ny+Nx of the ensemble matrix X, typically storing the state.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#Types","page":"Functions","title":"Types","text":"","category":"section"},{"location":"apidoc/","page":"Functions","title":"Functions","text":"Modules = [TransportBasedInference]\nOrder   = [:type]","category":"page"},{"location":"apidoc/#TransportBasedInference.AdditiveInflation-Tuple{Any,Int64,Int64}","page":"Functions","title":"TransportBasedInference.AdditiveInflation","text":"    (A::AdditiveInflation)(X, start::Int64, final::Int64)\n\nApply the additive inflation A to the lines start to final of an ensemble matrix X, i.e. xⁱ -> xⁱ + ϵⁱ with ϵⁱ ∼ A.α.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.AdditiveInflation-Tuple{Any}","page":"Functions","title":"TransportBasedInference.AdditiveInflation","text":"    (A::AdditiveInflation)(X)\n\nApply the additive inflation A to an ensemble matrix X, i.e. xⁱ -> xⁱ + ϵⁱ with ϵⁱ ∼ A.α.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.AdditiveInflation-Tuple{Array{Float64,1}}","page":"Functions","title":"TransportBasedInference.AdditiveInflation","text":"    (A::AdditiveInflation)(x::Array{Float64,1})\n\nApply the additive inflation A to the vector x, i.e. x -> x + ϵ with ϵ ∼ A.α.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.Hermite","page":"Functions","title":"TransportBasedInference.Hermite","text":"Hermite\n\nAn abstract type for 1D Hermite polynomials and functions\n\n\n\n\n\n","category":"type"},{"location":"apidoc/#TransportBasedInference.IdFilter","page":"Functions","title":"TransportBasedInference.IdFilter","text":"IdFilter <: SeqFilter\n\nAn immutable structure for the identity filter.\n\nFields\n\nΔtdyn::Float64: time-step of the dynamical model\nΔtobs::Float64: time-step between two observations\n\nConstructors\n\nIdFilter(Δtdyn, Δtobs): set up an identity filter\n\n\n\n\n\n","category":"type"},{"location":"apidoc/#TransportBasedInference.IdFilter-Tuple{Any,Any,Any}","page":"Functions","title":"TransportBasedInference.IdFilter","text":"(filter::IdFilter)(X, ystar, t)\n\nApplies the identity transformation to the ensemble `X`.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.IdentityInflation","page":"Functions","title":"TransportBasedInference.IdentityInflation","text":"IdentityInflation <: InflationType\n\nAn type to store identity inflation :\n\nDefine additive inflation: x <- x\n\n\n\n\n\n","category":"type"},{"location":"apidoc/#TransportBasedInference.IdentityInflation-Tuple{Any}","page":"Functions","title":"TransportBasedInference.IdentityInflation","text":"    (A::IdentityInflation)(X)\n\nApply an IdentityInflation A on an ensemble matrix X, i.e. xⁱ -> xⁱ\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.InflationType","page":"Functions","title":"TransportBasedInference.InflationType","text":"InflationType\n\n\n\nAn abstract type for Inflation.\n\n\n\n\n\n","category":"type"},{"location":"apidoc/#TransportBasedInference.InvPreconditioner","page":"Functions","title":"TransportBasedInference.InvPreconditioner","text":"InvPreconditioner\n\nAn immutable structure to hold the inverse of the preconditioner. For instance, this structure can be used to hold the estimate of the inverse of the Hessian in the BFGS algorithm.\n\n\n\n\n\n","category":"type"},{"location":"apidoc/#TransportBasedInference.LinearTransform","page":"Functions","title":"TransportBasedInference.LinearTransform","text":"LinearTransform\n\n\n\n\n\n","category":"type"},{"location":"apidoc/#TransportBasedInference.Model","page":"Functions","title":"TransportBasedInference.Model","text":"    Model\n\nA structure to perform the twin-experiment\n\nFields\n\nNx : Dimension of the state variable\nNy : Dimension of the observation variable\nΔtdyn : Time-step for the dynamical model\nΔtobs : Time step between two observations of the state\nϵx : Process noise\nϵy : Observation noise\nπ0 : Multivariate distribution for the initial condition\nTburn : Number of steps to burn from the end of the spin up to compute the metrics\nTstep : Number of steps for which the filter to be tested is applied\nTspinup : Number of steps of spin-up phase,  i.e. number of steps to generate the initial ensemble for the filtering algorithms\nF : State-Space Model\n\n\n\n\n\n","category":"type"},{"location":"apidoc/#TransportBasedInference.MultiAddInflation","page":"Functions","title":"TransportBasedInference.MultiAddInflation","text":"MultiAddInflation <: InflationType\n\nAn type to store multiplico-additive inflation :\n\nDefine multiplico-additive inflation: xⁱ -> x̄ + β*(xⁱ - x̄)  + ϵⁱ with ϵⁱ ∼ α and β a scalar\n\nFields:\n\nNx : dimension of the vector\n'β' : Multiplicative inflation factor\n'α' : Distribution of the additive inflation\n\nConstructors:\n\nMultiAddInflation(Nx::Int64, β::Real, α::ContinuousMultivariateDistribution)\nMultiAddInflation(Nx::Int64, β::Float64, m::Array{Float64,1}, Σ)\nMultiAddInflation(Nx::Int64, β::Float64, m::Array{Float64,1}, σ::Array{Float64,1})\nMultiAddInflation(Nx::Int64, β::Float64, m::Array{Float64,1}, σ::Float64)\n\n\n\n\n\n","category":"type"},{"location":"apidoc/#TransportBasedInference.MultiAddInflation-Tuple{Any,Int64,Int64}","page":"Functions","title":"TransportBasedInference.MultiAddInflation","text":"    (A::MultiAddInflation)(X, start::Int64, final::Int64)\n\nApply the multiplicat inflation A to the lines start to final of an ensemble matrix X, i.e. xⁱ -> x̄ + β*(xⁱ - x̄)  + ϵⁱ with ϵⁱ ∼ A.α and β a scalar, usually ∼ 1.0.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.MultiAddInflation-Tuple{Any}","page":"Functions","title":"TransportBasedInference.MultiAddInflation","text":"    (A::MultiAddInflation)(X, start::Int64, final::Int64)\n\nApply the multiplico-additive inflation A to the ensemble matrix X, i.e. xⁱ -> x̄ + β*(xⁱ - x̄)  + ϵⁱ with ϵⁱ ∼ A.α and β a scalar, usually ∼ 1.0.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.MultiplicativeInflation","page":"Functions","title":"TransportBasedInference.MultiplicativeInflation","text":"MultiplicativeInflation <: InflationType\n\nAn type to store multiplicative inflation :\n\nxⁱ -> xⁱ + β*(xⁱ - x̄) with β a scalar\n\nFields:\n\n'β' : multiplicative inflation factor\n\n\n\n\n\n","category":"type"},{"location":"apidoc/#TransportBasedInference.MultiplicativeInflation-Tuple{Any,Int64,Int64}","page":"Functions","title":"TransportBasedInference.MultiplicativeInflation","text":"    (A::MultiplicativeInflation)(X, start::Int64, final::Int64)\n\nApply the multiplicative inflation A to the lines start to final of an ensemble matrix X, i.e. xⁱ -> x̄ + β*(xⁱ - x̄)  with β scalar, usually ∼ 1.0.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.MultiplicativeInflation-Tuple{Any}","page":"Functions","title":"TransportBasedInference.MultiplicativeInflation","text":"    (A::MultiplicativeInflation)(X)\n\nApply the multiplicative inflation A to an ensemble matrix X, i.e. xⁱ -> x̄ + β*(xⁱ - x̄)  with β scalar, usually ∼ 1.0.\n\n\n\n\n\n","category":"method"},{"location":"apidoc/#TransportBasedInference.Parallel","page":"Functions","title":"TransportBasedInference.Parallel","text":"Parallel\n\nAn abstract type for the different kinds of parallel programming supported.\n\n\n\n\n\n","category":"type"},{"location":"apidoc/#TransportBasedInference.PhyHermite","page":"Functions","title":"TransportBasedInference.PhyHermite","text":"PhyHermite <: Hermite\n\nAn immutable structure for physicist Hermite functions defined as ψm(x) = Hm(x)*exp(-x^2/2).\n\nFields\n\nm : order of the function\nPoly : physicist Hermite polynomial of order m\nscaled : with rescaling to have unitary norm\n\nConstructors\n\nPhyHermite(m, Poly, scaled) PhyHermite(m; scaled = false)\n\n\n\n\n\n","category":"type"},{"location":"apidoc/#TransportBasedInference.SeqFilter","page":"Functions","title":"TransportBasedInference.SeqFilter","text":"SeqFilter\n\nAn abstract type for the ensemble filtering algorithms.\n\n\n\n\n\n","category":"type"},{"location":"apidoc/#TransportBasedInference.Serial","page":"Functions","title":"TransportBasedInference.Serial","text":"Serial <: Parallel\n\nA type for serial computing\n\n\n\n\n\n","category":"type"},{"location":"apidoc/#TransportBasedInference.StateSpace","page":"Functions","title":"TransportBasedInference.StateSpace","text":"struct StateSpace\n\nAn immutable structure representing the dynamical f and observation h operators. The dynamical model is provided by the right hand side of the ODE to solve. For a system of ODEs, we will prefer an in-place syntax f(du, u, p, t), where p are parameters of the model. We rely on OrdinaryDiffEq to integrate the dynamical system with the Tsitouras 5/4 Runge-Kutta method adaptive time marching. h must be a function of the form h(u, t), where u is the state vector and t is the time.\n\nFields\n\nf::Function\nPropagatation f\nh::Function\nObservation h\n\n\n\n\n\n","category":"type"},{"location":"apidoc/#TransportBasedInference.SyntheticData","page":"Functions","title":"TransportBasedInference.SyntheticData","text":"SyntheticData\n\nA structure to store the synthetic data in a twin-experiment\n\nFields\n\ntt : time history\nx0 : the initial condition\nxt : history of the state\nyt : history of the observations\n\n\n\n\n\n","category":"type"},{"location":"apidoc/#TransportBasedInference.Thread","page":"Functions","title":"TransportBasedInference.Thread","text":"Thread <: Parallel\n\nA type for multi-threaded computing\n\n\n\n\n\n","category":"type"},{"location":"apidoc/#Index","page":"Functions","title":"Index","text":"","category":"section"},{"location":"apidoc/","page":"Functions","title":"Functions","text":"Modules = [TransportBasedInference]\nOrder   = [:type]","category":"page"},{"location":"apidoc/","page":"Functions","title":"Functions","text":"Pages = [\"functions.md\"]","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/#.-Estimation-of-the-Banana-distribution","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"","category":"section"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"In this notebook, we will show how we can estimate a density pi given a limited number of samples boldsymbolx^i sim pi in mathbbR^N_x. We will rely on the adaptive estimation framework developed in Baptista et al. [1].","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"using LinearAlgebra\nusing TransportBasedInference\nusing Statistics\nusing Distributions\nnothing #hide","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"Load some packages to make nice figures","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"using Plots\ndefault(tickfont = font(\"CMU Serif\", 9),\n        titlefont = font(\"CMU Serif\", 14),\n        guidefont = font(\"CMU Serif\", 12),\n        legendfont = font(\"CMU Serif\", 10),\n        grid = false)\n\nusing LaTeXStrings\nusing ColorSchemes","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"We start by generating N_e samples from a banana distribution using the function sample_banana.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"Ne = 500 # Number of samples\nNx = 2 # Dimension of the state\n\n# Define the parameters of the banana distribution\nμ = 0.0\nσ = 2.0\nbananicity = 0.3\n\n# Generate the samples\nX = sample_banana(Ne, μ = μ, σ = σ, bananicity = bananicity)\nnothing #hide","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"X is an ensemble matrix whose columns are the different ensemble members, i.e. boldsymbolX = left boldsymbolx^1 ldots boldsymbolx^N_e right  in mathbbR^N_x times N_e.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"Nlog = 100\nlogbanana = zeros(Nlog, Nlog)\n\nxrange = range(-6.0; stop = 6.0, length = Nlog)\nyrange = range(-4.0; stop = 6.0, length = Nlog)\n\nfor (i,x) in enumerate(xrange)\n    for (j,y) in enumerate(yrange)\n        logbanana[i,j] = log_pdf_banana([x;y]; μ = μ, σ = σ, bananicity = bananicity)\n    end\nend\n\n\ncontour(xrange, yrange, exp.(logbanana)', ratio = 1,\n         title = \"True density\",\n         colorbar = false, grid = false,\n         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),\n         xlim = (xrange[1], xrange[end]), ylim = (-Inf, Inf), linewidth = 3)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"We define an object S of  type HermiteMap to hold the Knothe-Rosenblatt rearrangement that pushes forward pi to the reference density, i.e. the standard Gaussian distribution rho. The default constructor for an HermiteMap requires, where m is the maximal order of the Hermite polynomials considered in the expansion, N_x the dimension of the state, L a linear transformation that rescale the samples to get zero mean and unitary standard deviation component-wise, and C an array of N_x MapComponent.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"m = 30\nS = HermiteMap(m, X; diag = true, b = \"CstLinProHermite\")","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"The next step is to use the greedy algorithm developed by Baptista et al. (2020) [1] to construct a sparse expansion of the different components of the map S. Depending on the accuracy of the amp required. Several options are possible for the optimization:","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"kfold uses a k-fold cross validation procedure (the more robust choice)\nsplit splits the set of samples into a training and a testing\nAn Int64 to determine the maximum number of features for each component s^k of the map S\nnothing to simply optimize the existing coefficients in the basis expansion.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"optimize(S, X, \"kfold\"; withqr = true)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"The map S is an approximation of the pushforward of the target density pi, to the standard Gaussian density rho.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"We can access the different components of the map S as follows:","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"S[1]","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"S[2]","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"We can access the coefficients of the expansion for each map component with getcoeff.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"getcoeff(S[2])","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"plot(S[2].I.f)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"getidx can be used to obtain the active features of the different map components. The number of columns is the number of dimensions. Each line correspond to a multi-index for the different components.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"getidx(S[2])","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"Using PlotRecipes.jl, we plot the number of occurences of each variable (columns) in each map component (rows).","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"plot(S)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"By setting degree = true, we plot maximum multi-index of the features identified for each variable (columns) in each map component (rows)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"plot(S; degree = true)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"We can now compare the log-density of the true Banana density with the approximated one. Let's create a grid and evaluate the logpdf the densities.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"logbanana_approx = zeros(Nlog, Nlog)\nlognormal = zeros(Nlog, Nlog)\n\nfor (i,x) in enumerate(xrange)\n    for (j,y) in enumerate(yrange)\n        logbanana_approx[i,j] = log_pdf(S, reshape([x; y], (2,1)))[1]\n        lognormal[i,j] = logpdf(MvNormal(zeros(2), 1.0), [x;y])\n    end\nend\n\nplt = plot(layout = grid(1, 2), colorbar = false, grid = false)\ncontour!(plt[1,1], xrange, yrange, exp.(logbanana)', ratio = 1,\n         title = \"True density\",\n         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),\n         xlim = (xrange[1], xrange[end]), ylim = (-Inf, Inf), linewidth = 3)\n\ncontour!(plt[1,2], xrange, yrange, exp.(logbanana_approx)', ratio = 1,\n         title = \"ATM approximate\",\n         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),\n         xlim = (xrange[1], xrange[end]), ylim = (-Inf, Inf), linewidth = 3)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"We can overlap the estimated density with the samples","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"contour(xrange, yrange, exp.(logbanana_approx)', ratio = 1, colorbar = false,\n         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),\n         xlim = (-Inf, Inf), ylim = (-Inf, Inf), linewidth = 3)\nscatter!(X[1,:], X[2,:]; legend = false, color = :purple3, ratio = 1, markersize = 6)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"By definition, the map S pushes forward the samples boldsymbolx^i to the standard normal distribution rho of mathbbR^2, denoted boldsymbolS_sharp pi = rho,  i.e. boldsymbolx^i sim pi Rightarrow boldsymbolS(boldsymbolx^i) sim rho.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"SpushX = evaluate(S, X)\n\ncontour(xrange, yrange, exp.(lognormal)', ratio = 1, colorbar = false,\n         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),\n         xlim = (-Inf, Inf), ylim = (-Inf, Inf), linewidth = 3)\nscatter!(SpushX[1,:], SpushX[2,:]; legend = false, color = :purple3, ratio = 1, markersize = 6)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"We can compute the statistics of the pushed samples","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"mean(SpushX; dims = 2)[:,1] # close to zero","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"cov(SpushX; dims = 2) # close to the identity matrix","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"We can use the map boldsymbolS to generate new samples from the target density pi. The map boldsymbolS pulls back  samples boldsymbolz^i of the standard normal distribution rho to the target density pi, denoted boldsymbolS^sharp rho = pi, i.e. boldsymbolz^i sim rho Rightarrow boldsymbolS^-1(boldsymbolz^i) sim pi.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"Znew = randn(Nx, Ne)\nXnew = zeros(Nx, Ne)","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"We use the in-place routine inverse to solve the triangular system boldsymbolS(boldsymbolx^i) = boldsymbolz^i for boldsymbolx^i in mathbbR^N_x for the different samples. From the lower triangular structure of boldsymbolS, this inversion reduces to a sequence of one dimensional root finding problems Marzouk et al. [2].","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"inverse!(Xnew, copy(Znew), S)\nevaluate(S, Xnew)-Znew","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"plt = plot(layout = grid(1, 2))\n\ncontour!(plt[1,1], xrange, yrange, exp.(lognormal)', ratio = 1, colorbar = false,\n         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),\n         xlim = (xrange[1], xrange[end]), ylim = (yrange[1], yrange[end]), linewidth = 3)\nscatter!(plt[1,1], Znew[1,:], Znew[2,:]; legend = false, color = :purple3, ratio = 1, markersize = 6,\n         title = L\"z^i \\sim \\rho\")\n\ncontour!(plt[1,2], xrange, yrange, exp.(logbanana)', ratio = 1, colorbar = false,\n         color = cgrad([:dodgerblue4, :deepskyblue3, :skyblue, :olivedrab1, :yellow, :orange, :red, :firebrick]),\n         xlim = (xrange[1], xrange[end]), ylim = (yrange[1], yrange[end]), linewidth = 3)\nscatter!(plt[1,2], Xnew[1,:], Xnew[2,:]; legend = false, color = :purple3, ratio = 1, markersize = 6,\n            title = L\"S^{-1}(z^i) \\sim S^{\\sharp}\\rho\")","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"References:","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"[1]: Baptista, R., Zahm, O., & Marzouk, Y. (2020). An adaptive transport framework for joint and conditional density estimation. arXiv preprint arXiv:2009.10303.","category":"page"},{"location":"manual/1.-Estimation-of-the-Banana-distribution/","page":"1. Estimation of the Banana distribution","title":"1. Estimation of the Banana distribution","text":"[2]: Marzouk, Y., Moselhy, T., Parno, M., & Spantini, A. (2016). Sampling via measure transport: An introduction. Handbook of uncertainty quantification, 1-41.","category":"page"},{"location":"LICENSE/#LICENSE","page":"LICENSE","title":"LICENSE","text":"","category":"section"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"The TransportBasedInference.jl package is licensed under the MIT License:","category":"page"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"Copyright (c) 2021 Mathieu Le Provost","category":"page"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"LICENSE/","page":"LICENSE","title":"LICENSE","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"background/#Background","page":"Background","title":"Background","text":"","category":"section"},{"location":"#AdaptiveTransportMap.jl","page":"Home","title":"AdaptiveTransportMap.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A framework for Bayesian inference with transport maps","category":"page"},{"location":"","page":"Home","title":"Home","text":"The objective of this package is to allow for easy and fast resolution of Bayesian inference problems using transport maps. The package provides tools for:","category":"page"},{"location":"","page":"Home","title":"Home","text":"joint and conditional density estimation from limited samples of the target distribution using the adaptive transport map algorithm developed by Baptista et al. [1].\nsequential inference for state-space models using one of the following algorithms: the stochastic ensemble Kalman filter (Evensen [2]), the ensemble transform Kalman filter (Bishop et al. [3]) and a nonlinear generalization of the stochastic ensemble Kalman filter (Spantini et al. [4]).","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package has been designed to address the following question:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Given samples boldsymbolx^i sim pi For a random variable mathsfX sim pi where pi a complex distribution of interest, can we identify a transformation boldsymbolS such that the target distribution is pushed forward to a reference density eta (e.g. the standard Gaussian distribution).","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"[1]: Baptista, R., Zahm, O., & Marzouk, Y. (2020). An adaptive transport framework for joint and conditional density estimation. arXiv preprint arXiv:2009.10303.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[2]: Evensen, G., 1994. Sequential data assimilation with a nonlinear quasi‐geostrophic model using Monte Carlo methods to forecast error statistics. Journal of Geophysical Research: Oceans, 99(C5), pp.10143-10162.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[3]: Bishop, C.H., Etherton, B.J. and Majumdar, S.J., 2001. Adaptive sampling with the ensemble transform Kalman filter. Part I: Theoretical aspects. Monthly weather review, 129(3), pp.420-436.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[4]: Spantini, A., Baptista, R., & Marzouk, Y. (2019). Coupling techniques for nonlinear ensemble filtering. arXiv preprint arXiv:1907.00389.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[5]: Le Provost, M., Baptista, R., Marzouk, Y., & Eldredge, J. (2021). A low-rank nonlinear ensemble filter for vortex models of aerodynamic flows. In AIAA Scitech 2021 Forum (p. 1937).","category":"page"}]
}
